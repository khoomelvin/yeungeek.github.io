{"meta":{"title":"Yeungeek","subtitle":"Android 沉思录","description":"It's my Androad","author":"Yeungeek","url":"http://yeungeek.github.io","root":"/"},"pages":[{"title":"[404]","date":"2020-01-17T03:44:17.195Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"404.html","permalink":"http://yeungeek.github.io/404.html","excerpt":"","text":""},{"title":"About Me","date":"2019-06-13T14:51:46.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"about/index.html","permalink":"http://yeungeek.github.io/about/index.html","excerpt":"","text":"这是Yeungeek的个人站点. 现在是一枚Android攻城师，关注移动互联网."}],"posts":[{"title":"Android Camera-Camera1使用","slug":"AndroidCamera-UsingCamera1","date":"2020-01-17T09:32:39.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2020/01/17/AndroidCamera-UsingCamera1/","link":"","permalink":"http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/","excerpt":"Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了CameraView，提供给开发者参考和学习，现在最新的可以使用Jetpack CameraX来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。","text":"Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了CameraView，提供给开发者参考和学习，现在最新的可以使用Jetpack CameraX来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。 相机开发的流程： 检测设备摄像头，打开相机 创建预览画面，显示实时预览画面 设置相机参数，进行拍照监听 监听中，保存图片资源或者直接操作原始数据 释放相机资源 上面的是基本的相机开发流程，不同的Camera API在实现上会有不同，整体流程上还是统一的。 Camera1使用权限声明12345&lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt; 相机必须声明CAMERA权限，在Android6.0上，你还需要在代码中动态申请权限 12ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 开发流程下图是一个开发流程的导览： 打开相机1Camera.open() 该方法的系统源码实现 1234567891011public static Camera open() &#123; int numberOfCameras = getNumberOfCameras(); CameraInfo cameraInfo = new CameraInfo(); for (int i = 0; i &lt; numberOfCameras; i++) &#123; getCameraInfo(i, cameraInfo); if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123; return new Camera(i); &#125; &#125; return null;&#125; 这里会检查可用的摄像头，默认使用的CameraInfo.CAMERA_FACING_BACK后置摄像头 创建预览画面这里使用的是SurfaceView 123456789101112131415161718192021222324252627282930313233343536private SurfaceView mSurfaceView;private SurfaceHolder mSurfaceHolder;...mSurfaceHolder = mSurfaceView.getHolder();mSurfaceHolder.addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; ... startPreview(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; releaseCamera(); &#125;&#125;);...private void startPreview() &#123; try &#123; //设置实时预览 mCamera.setPreviewDisplay(mSurfaceHolder); //Orientation setCameraDisplayOrientation(); //开始预览 mCamera.startPreview(); startFaceDetect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 设置预览的时候，可以设置setPreviewCallback监听预览数据的回调 1void onPreviewFrame(byte[] data, Camera camera); 设置相机参数设置相机参数后，需要重新启动预览，这边在初始化的时候，已经设置好了。 1234567891011121314151617private void initParameters(final Camera camera) &#123; mParameters = camera.getParameters(); mParameters.setPreviewFormat(ImageFormat.NV21); //default if (isSupportFocus(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123; mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); &#125; else if (isSupportFocus(Camera.Parameters.FOCUS_MODE_AUTO)) &#123; mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO); &#125; //设置预览图片大小 setPreviewSize(); //设置图片大小 setPictureSize(); camera.setParameters(mParameters);&#125; Camera.Parameters可以设置的参数非常多，这里就介绍几个比较常用的 1.setFocusMode设置对焦模式 FOCUS_MODE_AUTO：自动对焦 FOCUS_MODE_INFINITY：无穷远 FOCUS_MODE_MACRO：微距 FOCUS_MODE_FIXED：固定焦距 FOCUS_MODE_EDOF：景深扩展 FOCUS_MODE_CONTINUOUS_PICTURE：持续对焦(针对照片) FOCUS_MODE_CONTINUOUS_VIDEO：(针对视频) 2.setPreviewSize设置预览图片大小 3.setPreviewFormat支持的格式： ImageFormat.NV16 ImageFormat.NV21 ImageFormat.YUY2 ImageFormat.YV12 ImgaeFormat.RGB_565 ImageFormat.JPEG如果不设置，默认返回NV21的数据 4.setPictureSize设置保存图片的大小 5.setPictureFormat设置保存图片的格式，格式和setPreviewFormat一样 6.setDisplayOrientation设置相机预览画面旋转的角度，degress取值0，90，180，270 7.setPreviewDisplay设置实时预览SurfaceHolder 8.setPreviewCallback监听相机预览数据回调 9.setParameters设置相机的Parameters其他一些设置，大家可以查看Android文档进行相应的设置 设置方向设置相机的预览方向，orientation比较详细的介绍 123456789101112131415161718192021222324252627282930313233private void setCameraDisplayOrientation() &#123; Camera.CameraInfo cameraInfo = new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, cameraInfo); int rotation = getWindowManager().getDefaultDisplay().getRotation(); //自然方向 int degrees = 0; switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; &#125; int result; //cameraInfo.orientation 图像传感方向 if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; result = (cameraInfo.orientation + degrees) % 360; result = (360 - result) % 360; &#125; else &#123; result = (cameraInfo.orientation - degrees + 360) % 360; &#125; mOrientation = result; //相机预览方向 mCamera.setDisplayOrientation(result);&#125; 拍照123456789101112131415161718192021private void takePicture() &#123; if (null != mCamera) &#123; mCamera.takePicture(new Camera.ShutterCallback() &#123; @Override public void onShutter() &#123; &#125; &#125;, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; //base data &#125; &#125;, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(final byte[] data, Camera camera) &#123; mCamera.startPreview(); //save data &#125; &#125;); &#125;&#125; takePicture的源码实现： 1234public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) &#123; takePicture(shutter, raw, null, jpeg); &#125; shutter(ShutterCallback)：快门按下后的回调 raw(PictureCallback)：raw图像数据 jpeg(PictureCallback)：jpeg图像生成以后的回调 释放相机资源在使用完成后，onPause或者onDestory中进行相机资源的释放 123456789private void releaseCamera() &#123; if (null != mCamera) &#123; mCamera.stopPreview(); mCamera.stopFaceDetection(); mCamera.setPreviewCallback(null); mCamera.release(); mCamera = null; &#125;&#125; stopPreview：停止预览 release：释放资源 Camera1的开发上，还是相对比较简单的，需要定制的功能项比较少，下面一篇开始介绍Camera2的使用。 参考 Android Camera 编程从入门到精通 Android之Camera1实现相机开发","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"}]},{"title":"Android Camera-基础知识篇","slug":"AndroidCamera-Basic","date":"2020-01-14T19:49:33.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2020/01/14/AndroidCamera-Basic/","link":"","permalink":"http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/","excerpt":"现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。","text":"现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。 基础知识Android Framework提供Camera API来实现拍照与录制视频的功能，目前Android有三类API， Camera此类是用于控制设备相机的旧版 API，现已弃用，在Android5.0以下使用 Camera2此软件包是用于控制设备相机的主要 API，Android5.0以上使用 CameraX基于Camera 2 API封装，简化了开发流程，并增加生命周期控制 相关开发类 android.hardware.camera2控制相机的核心API，使用它可以实现拍照和录制视频的功能。 Camera此类是用于控制设备相机的旧版 API，现已弃用。 SurfaceView此类用于向用户呈现实时相机预览。 TextureView也是用于实时相机预览，Android4.0之后引入 MediaRecorder用于录制视频 IntentMediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE 的 Intent 操作类型可用于捕获图像或视频，而无需直接使用 Camera 对象。 术语 ISO(感光度)CMOS（或胶卷）对光线的敏感程度，用ISO100的胶卷，相机2秒可以正确曝光的话，同样光线条件下用ISO200的胶卷只需要1秒即可，用ISO400则只要0.5秒。常见的标准：ISO100，ISO200，ISO400 曝光时间曝光时间是为了将光投射到相机感光片上，相机快门所要打开至关闭的时间 光圈用来控制光线透过镜头，进入相机内感光面光量的装置 焦距指的是平行的光线穿过镜片后，所汇集的焦点至镜片间之距离。数值越小，代表可以拍摄的角度越广，数值越大，代表可以拍摄的角度越小 景深拍摄时，当镜头聚集于某个被摄体时，这个被摄体就能在相机上结成清晰影像。使被摄体产生较为清晰影像的纵深的范围叫景深 测光测光模式：中央平均测光(average metering)、中央局部测光、点测光(spot metering)、多点测光、评价测光 自动曝光(Auto Exposure)相机根据光线条件自动来调整曝光时间等来确定曝光量 对焦对焦模式：自动对焦 AE(Auto Focus)、手动对焦 MF(Manual Focus)自动对焦分为对比度对焦(contrast)、相位对焦(PDAF: Phase Detection Auto Focus)和混合对焦(hybrid) 闪光灯(Flashlight)通过闪光灯打闪照亮物体来达到拍出清晰图片的目的 ScreenFlash通过屏幕打闪，照亮周围物体，拍出高清图片 高动态范围图像(HDR)HDR全称是High-Dynamic Range，即高动态范围图像技术。在拍照过程中开启HDR，可以让原先的暗场景变得更明亮更通透。 零延时拍照(ZSD)为了减少拍照延时,让拍照&amp;回显瞬间完成的一种技术 连拍(ContinuousShot)通过节约数据传输时间来捕捉摄影时机 预览大小(PreviewSize)相机预览图片的大小 拍照大小(PictureSize)拍照生成图片的大小 自动白平衡(Auto white balance)AWB(Auto white balance)，自动白平衡是相机的默认设置，相机中有一结构复杂的矩形图，它可决定画面中的白平衡基准点，以此来达到白平衡调校 对比度图像最亮和最暗之间的区域之间的比率，比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富 饱和度指色彩的鲜艳程度 锐度是反映图像平面清晰度和图像边缘锐利程度的一个指标 相机功能Android 支持多种相机功能，您可使用相机应用控制这些功能，如图片格式、闪光模式、对焦设置等等。通过Camera.Parameters可以设置大部分的功能，下面介绍几个重要功能： 区域测光和对焦 人脸检测 延时视频 区域测光和对焦从 Android 4.0（API 级别 14）开始，通过Camera.Parameters来确定对焦或亮度设置的区域，然后进行拍照或者录像 人脸检测这个和真正的人脸识别是不一样的 ，这里仅仅是检测人脸。通过照片分析，检测照片中是否包含人脸，使用人脸识别技术来识别人脸并计算照片设置 延时视频延时视频功能允许用户将间隔几秒钟或几分钟拍摄的图片串联起来，创建视频剪辑。使用MediaRecorder录制时间流逝片段的图像。 其他重要功能API： 参考 CameraX Camera Detecting camera features with Camera2 Android相机开发 - 1)基础概览篇 Android之Camera1实现相机开发","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"}]},{"title":"Android Camera-系列文章","slug":"AndroidCamera-Series","date":"2020-01-13T10:44:49.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2020/01/13/AndroidCamera-Series/","link":"","permalink":"http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/","excerpt":"最近比较忙，文章也很久没有更新了。最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到了，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。","text":"最近比较忙，文章也很久没有更新了。最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到了，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。 系列文章目录 Camera基础知识 Camera1使用 Camera2使用 Google CameraView使用 AndroidX使用 应用场景分析-扫码 应用场景分析-人脸识别 Google CameraView源码分析 AndroidX源码分析 Camera系统源码分析 参考 Android Camera AndroidX Android Camera 编程从入门到精通","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"}]},{"title":"Android NDK-深入理解JNI","slug":"AndroidNDK-DeepUnderstandJNI","date":"2019-08-21T11:21:43.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/08/21/AndroidNDK-DeepUnderstandJNI/","link":"","permalink":"http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/","excerpt":"Java调用C/C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。","text":"Java调用C/C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。 JNI 概述JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native语言的一种特性，通过JNI可以使JAVA和 C/C++进行交互。Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。在Java语言出现前，就有很多程序和库都是由Native语言写的，如果想重复利用这些库，就可以所使用JNI来实现。在Android平台上，JNI就是一座将Java世界和Native世界联通的一座桥梁。通过JNI，Java世界和Native世界的代码就可以相互访问了。 JNI实例：Camera最新有在看系统的Camera相关，所以从系统Camera角度来分析下JNI的应用，下面讲的实例基于Camera2 Android5.0(21)之后android.hardware.Camera就被废弃了，取而代之的是全新的android.hardware.Camera2 相关代码： 1234frameworks/base/core/jni/AndroidRuntime.cppframeworks/base/core/java/android/hardware/camera2/impl/CameraMetadataNative.javaframeworks/base/core/jni/android_hardware_camera2_CameraMetadata.cpp Camera2 Java层对应的是CameraMetadataNative.java，Native层对应的是android_hardware_camera2_CameraMetadata.cpp Java层CameraMetadataNative相关代码在CameraMetadataNative.javaCamera2使用CameraManager(摄像头管理器)进行控制，CameraManager具体的操作会通过CameraMetadataNative来执行。CameraMetadataNative的初始化 12345678910public class CameraMetadataNative implements Parcelable static &#123; /* * We use a class initializer to allow the native code to cache some field offsets */ nativeClassInit(); registerAllMarshalers(); &#125; private static native void nativeClassInit();&#125; 静态方法初始化调用了Native层的方法nativeClassInit，这个方法对应的Native层具体实现，是在android_hardware_camera2_CameraMetadata.cpp Native层CameraMetadataNative层相关代码在android_hardware_camera2_CameraMetadata.cppNative方法初始化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static const JNINativeMethod gCameraMetadataMethods[] = &#123;// static methods &#123; \"nativeClassInit\", \"()V\", (void *)CameraMetadata_classInit &#125;, //和Java层nativeClassInit()对应 &#123; \"nativeGetAllVendorKeys\", \"(Ljava/lang/Class;)Ljava/util/ArrayList;\", (void *)CameraMetadata_getAllVendorKeys&#125;, &#123; \"nativeGetTagFromKey\", \"(Ljava/lang/String;)I\", (void *)CameraMetadata_getTagFromKey &#125;, &#123; \"nativeGetTypeFromTag\", \"(I)I\", (void *)CameraMetadata_getTypeFromTag &#125;, &#123; \"nativeSetupGlobalVendorTagDescriptor\", \"()I\", (void*)CameraMetadata_setupGlobalVendorTagDescriptor &#125;,// instance methods &#123; \"nativeAllocate\", \"()J\", (void*)CameraMetadata_allocate &#125;, &#123; \"nativeAllocateCopy\", \"(L\" CAMERA_METADATA_CLASS_NAME \";)J\", (void *)CameraMetadata_allocateCopy &#125;, &#123; \"nativeIsEmpty\", \"()Z\", (void*)CameraMetadata_isEmpty &#125;, &#123; \"nativeGetEntryCount\", \"()I\", (void*)CameraMetadata_getEntryCount &#125;, &#123; \"nativeClose\", \"()V\", (void*)CameraMetadata_close &#125;, &#123; \"nativeSwap\", \"(L\" CAMERA_METADATA_CLASS_NAME \";)V\", (void *)CameraMetadata_swap &#125;, &#123; \"nativeReadValues\", \"(I)[B\", (void *)CameraMetadata_readValues &#125;, &#123; \"nativeWriteValues\", \"(I[B)V\", (void *)CameraMetadata_writeValues &#125;, &#123; \"nativeDump\", \"()V\", (void *)CameraMetadata_dump &#125;,// Parcelable interface &#123; \"nativeReadFromParcel\", \"(Landroid/os/Parcel;)V\", (void *)CameraMetadata_readFromParcel &#125;, &#123; \"nativeWriteToParcel\", \"(Landroid/os/Parcel;)V\", (void *)CameraMetadata_writeToParcel &#125;,&#125;; gCameraMetadataMethods什么时候会被加载？ 12345678910111213141516int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)&#123; ...... // Register native functions return RegisterMethodsOrDie(env, CAMERA_METADATA_CLASS_NAME, gCameraMetadataMethods, NELEM(gCameraMetadataMethods));&#125;......static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) &#123; int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods); LOG_ALWAYS_FATAL_IF(res &lt; 0, \"Unable to register native methods.\"); return res;&#125; register_android_hardware_camera2_CameraMetadata何时会被调用到，这个就需要了解下JNI的查找方式。 JNI查找方式 Android系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。 刚才CameraMetadata中register_android_hardware_camera2_CameraMetadata方法，在AndroidRuntime.cpp的声明： 1extern int register_android_hardware_camera2_CameraMetadata(JNIEnv *env); 然后在gRegJNI中的静态声明 12345static const RegJNIRec gRegJNI[] = &#123; ...... REG_JNI(register_android_hardware_camera2_CameraMetadata), ......&#125; gRegJNI方法在startReg中被调用 1234567891011121314151617/*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; ATRACE_NAME(\"RegisterAndroidNatives\"); androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); env-&gt;PushLocalFrame(200); if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); //createJavaThread(\"fubar\", quickTest, (void*) \"hello\"); return 0;&#125; register_jni_procs(gRegJNI, NELEM(gRegJNI), env)会循环调用gRegJNI数组成员所对应的方法 123456789101112static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123;#ifndef NDEBUG ALOGD(\"----------!!! %s failed to load\\n\", array[i].mName);#endif return -1; &#125; &#125; return 0;&#125; 这样android_hardware_camera2_CameraMetadata.cpp中的int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)就会被调用到。除了这种Android系统启动时，就注册JNI所对应的方法。还有一种就是程序自定义的JNI方法，以 MediePlay 为例：相关代码路径 12frameworks/base/media/java/android/media/MediaPlayer.javaframeworks/base/media/jni/android_media_MediaPlayer.cpp MediaPlayer声明： 1234567891011public class MediaPlayer extends PlayerBase implements SubtitleController.Listener&#123; ...... private static native final void native_init(); ...... static &#123; System.loadLibrary(\"media_jni\"); native_init(); &#125;&#125; 静态代码块中使用System.loadLibrary加载动态库，media_jni在Android平台对应的是libmedia_jni.so库。在jni目录/frameworks/base/media/jni/Android.mk中有相应的声明： 1234LOCAL_SRC_FILES:= \\android_media_MediaPlayer.cpp \\...LOCAL_MODULE:= libmedia_jni 在android_media_MediaPlayer.cpp找到对应的Native(natvie_init)方法： 1234567891011static voidandroid_media_MediaPlayer_native_init(JNIEnv *env)&#123; jclass clazz; clazz = env-&gt;FindClass(\"android/media/MediaPlayer\"); if (clazz == NULL) &#123; return; &#125; ......&#125; JNI注册的方法就是上面描述的两种方法： 在Android系统启动时注册，在AndroidRuntime.cpp中的gRegJNI方法中声明 使用System.loadLibrary()方式注册 JNI基础上面一节主要描述了系统中Java层和Native层交互和实现，并没有对JNI的基础理论，流程进行分析 JNI命名规则JNI方法名规范 : 1返回值 + Java前缀 + 全路径类名 + 方法名 + 参数① JNIEnv + 参数② jobject + 其它参数 简单的一个例子，返回一个字符串 123456extern \"C\" JNIEXPORT jstring JNICALLJava_com_yeungeek_jnisample_NativeHelper_stringFromJNI(JNIEnv *env, jclass jclass1) &#123; LOGD(\"##### from c\"); return env-&gt;NewStringUTF(\"Hello JNI\");&#125; 返回值：jstring 全路径类名：com_yeungeek_jnisample_NativeHelper 方法名：stringFromJNI JNI开发流程 在Java中先声明一个native方法 编译Java源文件javac得到.class文件 通过javah -jni命令导出JNI的.h头文件 使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。） 将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib) 通过Java命令执行Java程序，最终实现Java调用本地代码。 数据类型基本数据类型 Signature Java Native B byte jbyte C char jchar D double jdouble F float jfloat I int jint S short jshort J long jlong Z boolean jboolean V void jvoid 引用数据类型 Signature Java Native L+classname +; Object jobject Ljava/lang/String; String jstring [L+classname +; Object[] jobjectArray Ljava.lang.Class; Class jclass Ljava.lang.Throwable; Throwable jthrowable [B byte[] jbyteArray [C char[] jcharArray [D double[] jdoubleArray [F float[] jfloatArray [I int[] jintArray [S short[] jshortArray [J long[] jlongArray [Z boolean[] jbooleanArray 方法签名JNI的方法签名的格式： 1(参数签名格式...)返回值签名格式 demo的native 方法： 1public static native java.lang.String stringFromJNI(); 可以通过javap命令生成方法签名``： 1()Ljava/lang/String; JNI原理Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。JNI 定义了两个关键数据结构，即“JavaVM”和“JNIEnv”，两者本质上都是指向函数表的二级指针。 JavaVMJavaVM是Java虚拟机在JNI层的代表，JavaVM 提供了“调用接口”函数，您可以利用此类函数创建和销毁 JavaVM。理论上，每个进程可以包含多个JavaVM，但AnAndroid只允许每个进程包含一个JavaVM。 JNIEnvJNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。JNIEnv 提供了大多数 JNI 函数。您的原生函数均会接收 JNIEnv 作为第一个参数。JNIEnv作用： 调用Java函数 操作Java代码 JNIEnv定义(jni.h)：libnativehelper/include/nativehelper/jni.h 1234567#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM; #elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif 定义中可以看到JavaVM，Android中一个进程只会有一个JavaVM，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构 注册JNI函数Java世界和Native世界的方法是如何关联的，就是通过JNI函数注册来实现。JNI函数注册有两种方式： 静态注册这种方法就是通过函数名来找对应的JNI函数，可以通过javah命令行来生成JNI头文件 1javah com.yeungeek.jnisample.NativeHelper 生成对应的com_yeungeek_jnisample_NativeHelper.h文件，生成对应的JNI函数，然后在实现这个函数就可以了 1234567/* * Class: com_yeungeek_jnisample_NativeHelper * Method: stringFromJNI * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI (JNIEnv *, jclass); 静态注册方法中，Native是如何找到对应的JNI函数，在JNI查找方式中介绍系统的流程，并没有详细说明静态注册的查找。这里简单说明下这个过程(以上面的声明为例子s)：当Java调用native stringFromJNI函数时，会从对应JNI库中查找Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI函数，如果没有找到，就会报错。静态注册方法，就是根据函数名来关联Java函数和JNI函数，JNI函数需要遵循特定的格式，这其中就有一些缺点： 声明了native方法的Java类，需要通过javah来生成头文件 JNI函数名称非常长 第一次调用native函数，需要通过函数名来搜索关联对应的JNI函数，效率比较低 如何解决这些问题，让native函数，提前知道JNI函数，就可以解决这个问题，这个过程就是动态注册。 动态注册动态注册在前面的Camera例子中，已经有涉及到，JNI函数classInit的声明。 1234567static const JNINativeMethod gCameraMetadataMethods[] = &#123;// static methods &#123; \"nativeClassInit\", \"()V\", (void *)CameraMetadata_classInit &#125;, //和Java层nativeClassInit()对应 ......&#125; JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativeMethod，它在jni.h中被定义： 12345typedef struct &#123; const char* name; //Java层native函数名 const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型 void* fnPtr; //Native层对应的函数指针&#125; JNINativeMethod; 在JNI查找方式说到，JNI注册的两种时间，第一种已经介绍过了，我们自定义的native函数，基本都是会使用System.loadLibrary(“xxx”)，来进行JNI函数的关联。 loadLibrary(Android7.0)123public static void loadLibrary(String libname) &#123; Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);&#125; 调用到Runtime(libcore/ojluni/src/main/java/java/lang/Runtime.java)的loadLibrary0方法： 123456789101112131415161718192021222324252627282930313233343536synchronized void loadLibrary0(ClassLoader loader, String libname) &#123; ...... String libraryName = libname; if (loader != null) &#123; String filename = loader.findLibrary(libraryName); if (filename == null) &#123; // It's not necessarily true that the ClassLoader used // System.mapLibraryName, but the default setup does, and it's // misleading to say we didn't find \"libMyLibrary.so\" when we // actually searched for \"liblibMyLibrary.so.so\". throw new UnsatisfiedLinkError(loader + \" couldn't find \\\"\" + System.mapLibraryName(libraryName) + \"\\\"\"); &#125; //doLoad String error = doLoad(filename, loader); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125; return; &#125; //loader 为 null ...... for (String directory : getLibPaths()) &#123; String candidate = directory + filename; candidates.add(candidate); if (IoUtils.canOpenReadOnly(candidate)) &#123; String error = doLoad(candidate, loader); if (error == null) &#123; return; // We successfully loaded the library. Job done. &#125; lastError = error; &#125; &#125; ......&#125; doLoad123456private String doLoad(String name, ClassLoader loader) &#123; //调用 native 方法 synchronized (this) &#123; return nativeLoad(name, loader, librarySearchPath); &#125;&#125; nativeLoad进入到虚拟机代码/libcore/ojluni/src/main/native/Runtime.c 123456JNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename, jobject javaLoader, jstring javaLibrarySearchPath)&#123; return JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);&#125; 然后调用JVM_NativeLoad，JVM_NativeLoad方法申明在jvm.h中，实现在OpenjdkJvm.cc(/art/runtime/openjdkjvm/OpenjdkJvm.cc) 1234567891011121314151617181920212223242526JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env, jstring javaFilename, jobject javaLoader, jstring javaLibrarySearchPath) &#123; ScopedUtfChars filename(env, javaFilename); if (filename.c_str() == NULL) &#123; return NULL; &#125; std::string error_msg; &#123; art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM(); bool success = vm-&gt;LoadNativeLibrary(env, filename.c_str(), javaLoader, javaLibrarySearchPath, &amp;error_msg); if (success) &#123; return nullptr; &#125; &#125; // Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF. env-&gt;ExceptionClear(); return env-&gt;NewStringUTF(error_msg.c_str());&#125; LoadNativeLibrary调用JavaVMExt的LoadNativeLibrary方法，方法在(art/runtime/java_vm_ext.cc)中，这个方法代码非常多，选取主要的部分进行分析 12345678910111213141516171819202122232425262728293031323334353637bool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jstring library_path, std::string* error_msg) &#123; ...... bool was_successful = false; //加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功， //如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数， //所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用java中申明的native方法时会抛出异常 void* sym = library-&gt;FindSymbol(\"JNI_OnLoad\", nullptr); if (sym == nullptr) &#123; VLOG(jni) &lt;&lt; \"[No JNI_OnLoad found in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; was_successful = true; &#125; else &#123; // Call JNI_OnLoad. We have to override the current class // loader, which will always be \"null\" since the stuff at the // top of the stack is around Runtime.loadLibrary(). (See // the comments in the JNI FindClass function.) ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride())); self-&gt;SetClassLoaderOverride(class_loader); VLOG(jni) &lt;&lt; \"[Calling JNI_OnLoad in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; typedef int (*JNI_OnLoadFn)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym); //调用JNI_OnLoad方法 int version = (*jni_on_load)(this, nullptr); if (runtime_-&gt;GetTargetSdkVersion() != 0 &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= 21) &#123; // Make sure that sigchain owns SIGSEGV. EnsureFrontOfChain(SIGSEGV); &#125; self-&gt;SetClassLoaderOverride(old_class_loader.get()); &#125; ......&#125; 代码里的主要逻辑： 加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功 如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数 所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用Java中的native方法时会抛出异常 jclass、jmethodID和jfieldID如果要通过原生代码访问对象的字段，需要执行以下操作： 使用 FindClass 获取类的类对象引用 使用 GetFieldID 获取字段的字段 ID 使用适当内容获取字段的内容，例如 GetIntField 具体的使用，放在第二篇文章中讲解 JNI的引用JNI规范中定义了三种引用： 局部引用（Local Reference） 全局引用（Global Reference） 弱全局引用（Weak Global Reference） 局部引用也叫本地引用，在 JNI层函数使用的非全局引用对象都是Local Reference，最大的特点就是，JNI 函数返回后，这些声明的引用可能就会被垃圾回收 全局引用这种声明的对象，不会主动释放资源，不会被垃圾回收 弱全局引用一种特殊的全局引用，在运行过程中可能被回收，使用之前需要判断下是否为空 参考 Android：清晰讲解JNI 与 NDK（含实例教学） Android JNI学习 Android JNI原理分析 Android深入理解JNI（一）JNI原理与静态、动态注册 JNI Tips","categories":[{"name":"Android框架层","slug":"Android框架层","permalink":"http://yeungeek.github.io/categories/Android框架层/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"http://yeungeek.github.io/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"http://yeungeek.github.io/tags/NDK/"}]},{"title":"Android网络编程-Retrofit源码角度分析Http","slug":"Network-Retrofit","date":"2019-07-25T19:31:38.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/07/25/Network-Retrofit/","link":"","permalink":"http://yeungeek.github.io/2019/07/25/Network-Retrofit/","excerpt":"上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。Retofit是一个RESTful的HTTP网络请求框架，有以下特点： 基于OKHttp 通过注解配置网络请求参数 支持同步、异步请求 支持多种序列化、反序列化格式 解耦彻底、模块高度封装，使用很多设计模式来实现","text":"上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。Retofit是一个RESTful的HTTP网络请求框架，有以下特点： 基于OKHttp 通过注解配置网络请求参数 支持同步、异步请求 支持多种序列化、反序列化格式 解耦彻底、模块高度封装，使用很多设计模式来实现 基本使用下面讲解的是官网的例子 创建网络请求接口1234public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125; 创建Retrofit实例(使用建造者模式)1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 创建网络接口实例123GitHubService service = retrofit.create(GitHubService.class);Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"yeungeek\"); 发送网络请求默认返回的是OKHttpCall，实际真正发送请求的就是OKHttp 同步1Response&lt;List&lt;Repo&gt;&gt; list = repos.execute() 异步123456789call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 请求流程具体的请求流程可以分为7大步骤 解析网络请求接口的注解，配置网络请求参数 通过动态代理生成网络请求对象 通过CallAdapter，将网络请求对象进行平台适配(Android,Java8) 通过网络请求执行器(Call)，发送网络请求 通过Converter进行数据解析 通过回调执行器，进行线程切换 在主线程处理返回结果 Refrofit最大特点是使用了大量的设计模式，来进行解耦，下图是完整的流程图(来自Stay 在 Retrofit分析-漂亮的解耦套路)：接下来通过源码分析，详细讲解上面的流程 源码分析Retrofit初始化123456Retrofit retrofit = new Retrofit //1. Retrofit声明 .Builder() //2. Builder .baseUrl(\"https://api.github.com/\") //3. baseUrl .addConverterFactory(GsonConverterFactory.create()) //4. Converter Factory .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //5. CallAdapter Factory .build(); //6. 生成实例 Retrofit声明在使用Retrofit时，首先通过建造者模式构建Retrofit。 12345678910111213141516171819202122public final class Retrofit &#123; private final Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); final okhttp3.Call.Factory callFactory; final HttpUrl baseUrl; final List&lt;Converter.Factory&gt; converterFactories; final List&lt;CallAdapter.Factory&gt; callAdapterFactories; final @Nullable Executor callbackExecutor; final boolean validateEagerly; Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories, @Nullable Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = converterFactories; // Copy+unmodifiable at call site. this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; ......&#125; serviceMethodCache：网络请求配置对象缓存，通过解析网络请求接口后得到请求对象 callFactory：网络请求器工厂(Call)，默认实现是OKHttp baseUrl：网络请求Url地址 converterFactories：数据转换器工厂集合 callAdapterFactories：请求适配器工厂集合 callbackExecutor：回调方法执行器 validateEagerly：是否提前验证请求方法 剩下的步骤都是来初始化上面的参数 Builder123456789101112131415161718public static final class Builder &#123; private final Platform platform; private @Nullable okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; &#125; public Builder() &#123; this(Platform.get()); &#125; ......&#125; Builder中的参数和 Retrfit 是意义一一对应的，默认构造函数进行平台的选择 123456789101112131415161718192021222324class Platform &#123; private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(\"java.util.Optional\"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ......&#125; 通过反射来判断选择Android还是Java8，以前版本还有对IOS平台的支持，最新版本已经去掉了。我们看下Android平台： 1234567891011121314151617181920static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; //默认回调执行器，会切换到主线程 return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); //默认的 CallAdapter return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; baseUrl12345678910111213141516171819public Builder baseUrl(String baseUrl) &#123; checkNotNull(baseUrl, \"baseUrl == null\"); HttpUrl httpUrl = HttpUrl.parse(baseUrl); if (httpUrl == null) &#123; throw new IllegalArgumentException(\"Illegal URL: \" + baseUrl); &#125; return baseUrl(httpUrl); &#125;......public Builder baseUrl(HttpUrl baseUrl) &#123; checkNotNull(baseUrl, \"baseUrl == null\"); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); //检查合法性 if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) &#123; throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl); &#125; this.baseUrl = baseUrl; return this;&#125; 把String url 转换成HttpUrl，会对baseUrl进行合法性校验(URL参数是不是以”/“结尾) ConverterFactory1234public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, \"factory == null\")); return this; &#125; 把factory加到数据转换器集合中，看下GsonFactory.create()具体的实现： 123456789101112131415161718192021222324public static GsonConverterFactory create(Gson gson) &#123; if (gson == null) throw new NullPointerException(\"gson == null\"); return new GsonConverterFactory(gson);&#125;private final Gson gson;private GsonConverterFactory(Gson gson) &#123; this.gson = gson;&#125;@Overridepublic Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);&#125;@Overridepublic Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter);&#125; GsonConverterFactory使用Gson 为初始化参数，实现responseBodyConverter和requestBodyConverter接口，进行真正的数据转换处理。 CallAdapterFactory1234public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123; callAdapterFactories.add(checkNotNull(factory, \"factory == null\")); return this;&#125; 把factory加到请求适配器工厂集合中，Android 平台默认实现是ExecutorCallAdapterFactory，后面再进行详细讲解。 build最后一步build生成Retrofit对象 12345678910111213141516171819202122232425262728293031public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(\"Base URL required.\"); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(1 + this.converterFactories.size()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);&#125; callFactory配置，默认OkHttpClient callbackExecutor配置，Android 平台默认使用MainThreadExecutor callAdapterFactories配置，先加入自定义的callAdapter，然后再加入defaultCallAdapterFactory converterFactories配置，先加入内建转换器(BuiltInConverters)，然后加入自定义的数据转换器 生成Retrofit对象 创建网络接口实例12345678public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125;//创建接口实例GitHubService service = retrofit.create(GitHubService.class);//生成请求对象Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"yeungeek\"); Retrofit通过外观模式和动态代理生成网络接口实例，网络接口的请求参数从接口声明获取 create123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); &#125; &#125;);&#125; create方法中最重要的是使用了动态代理，调用接口的方法都会到Proxy的invoke方法中，在invoke方法中最重要的就是下面三行代码 1234ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall); loadServiceMethod该方法读取网络请求接口里的方法，根据配置生成ServiceMethod对象 123456789101112ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; loadServiceMethod会先从cache中获取对象，如果获取不到，则通过建造者模式生成ServiceMethod对象。 1new ServiceMethod.Builder&lt;&gt;(this, method).build(); ServiceMethod123456789101112131415161718192021222324252627282930313233343536final class ServiceMethod&lt;R, T&gt; &#123; // Upper and lower characters, digits, underscores, and hyphens, starting with a character. static final String PARAM = \"[a-zA-Z][a-zA-Z0-9_-]*\"; static final Pattern PARAM_URL_REGEX = Pattern.compile(\"\\\\&#123;(\" + PARAM + \")\\\\&#125;\"); static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM); private final okhttp3.Call.Factory callFactory; private final CallAdapter&lt;R, T&gt; callAdapter; private final HttpUrl baseUrl; private final Converter&lt;ResponseBody, R&gt; responseConverter; private final String httpMethod; private final String relativeUrl; private final Headers headers; private final MediaType contentType; private final boolean hasBody; private final boolean isFormEncoded; private final boolean isMultipart; private final ParameterHandler&lt;?&gt;[] parameterHandlers; ServiceMethod(Builder&lt;R, T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; &#125; ......&#125; callFactory：网络请求器工厂，和retrofit对象声明中的含义一样 callAdapter：网络请求适配器工厂 baseUrl：网络请求Url地址 responseConverter：Response 数据转换器 httpMethod：http 请求方法 relativeUrl：网络请求相对地址 headers：网络请求头 contentType：网络请求 body 类型 parameterHandlers：方法处理解析器 ServiceMethod.Builder1234567Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations();&#125; methodAnnotations：网络请求接口方法注解 parameterTypes：网络请求接口方法里的参数注解 parameterAnnotationsArray：网络请求接口方法里的注解内容 build1234567891011121314151617181920212223242526272829303132333435public ServiceMethod build() &#123; //1. 从 Retrofit 中获取网络请求器 callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(\"'\" + Utils.getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); &#125; //2. 从 Refrofit 中获取数据转换器 responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; //3. 解析网络请求接口中方法的注解 parseMethodAnnotation(annotation); &#125; ..... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, \"No Retrofit annotation found.\"); &#125; //4. 创建ParameterHandler&lt;?&gt;，用来解析来解析参数使用到注解 parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; ...... return new ServiceMethod&lt;&gt;(this);&#125; createCallAdapter：根据接口方法返回类型、接口请求的注解，获取网络请求器 12345678910111213141516171819private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; //获取接口方法的返回类型 Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( \"Method return type must not include a type variable or wildcard: %s\", returnType); &#125; if (returnType == void.class) &#123; throw methodError(\"Service methods cannot return void.\"); &#125; //获取接口请求的注解 Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, \"Unable to create call adapter for %s\", returnType); &#125;&#125; createResponseConverter：根据接口请求注解类型、返回类型，获取数据数据转换器 12345678910private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; //获取接口请求的注解 Annotation[] annotations = method.getAnnotations(); try &#123; //从Rtrofit中获取数据转换器 return retrofit.responseBodyConverter(responseType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, \"Unable to create converter for %s\", responseType); &#125;&#125; parseMethodAnnotation：解析请求接口的方法注解，主要有以下标签 Http请求方法 Headers Multipart FormUrlEncoded parseParameter：对方法的参数注解进行解析包含：Url，Path，Query，QueryName，QueryMap，Header，HeaderMap，Field，FieldMap，Part，PartMap，Body 1234567891011121314151617181920private ParameterHandler&lt;?&gt; parseParameter( int p, Type parameterType, Annotation[] annotations) &#123; ParameterHandler&lt;?&gt; result = null; for (Annotation annotation : annotations) &#123; //参数注解解析 ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation( p, parameterType, annotations, annotation); if (annotationAction == null) &#123; continue; &#125; if (result != null) &#123; throw parameterError(p, \"Multiple Retrofit annotations found, only one allowed.\"); &#125; result = annotationAction; &#125; if (result == null) &#123; throw parameterError(p, \"No Retrofit annotation found.\"); &#125; return result;&#125; OKHttpCall根据serviceMethod和请求参数，创建OkHttpCall对象 12345678910111213141516171819final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final @Nullable Object[] args; private volatile boolean canceled; @GuardedBy(\"this\") private @Nullable okhttp3.Call rawCall; @GuardedBy(\"this\") // Either a RuntimeException, non-fatal Error, or IOException. private @Nullable Throwable creationFailure; @GuardedBy(\"this\") private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; ......&#125; serviceMethod和 args不做介绍了 rawCall：OKHttp，真正发送网络请求 canceled：取消请求标志位 executed：是否执行标志位 creationFailure：异常标志位 adapt根据ServiceMethod的中的callAdapter，来真正执行adapt方法ServiceMethod的adapt方法 123T adapt(Call&lt;R&gt; call) &#123; return callAdapter.adapt(call);&#125; Android 默认的返回 ExecutorCallAdapterFactory的Call这里使用了静态代理delegate，加入一些额外的操作 12345678public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallAdapterFactory.ExecutorCallbackCall(ExecutorCallAdapterFactory.this.callbackExecutor, call);&#125;......ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate;&#125; RxJavaCallAdapterFactory返回的是Observable 1234567891011121314151617181920212223242526272829@Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable;&#125; 经过上面几步操作 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;)，返回了一个 OKHttpCall 对象。 发送网络请求请求和 OKHttp 一样，分为同步请求和异步请求 同步请求execute 首先会调用ExecutorCallbackCall的execute方法： 123@Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute();&#125; delegate代理实际是 OKHttpCall，最终会调用OKHttpCall的execute方法 12345678910111213141516171819@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; ...... call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; throwIfFatal(e); // Do not assign a fatal error to creationFailure. creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; return parseResponse(call.execute());&#125; createRawCall创建真正发送的请求Request对象 123456789101112131415161718192021222324private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = serviceMethod.toCall(args); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call;&#125;//调用serviceMethod的 toCall 方法okhttp3.Call toCall(@Nullable Object... args) throws IOException &#123; //Request 的 builder 生成 Reuqest 对象 RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); @SuppressWarnings(\"unchecked\") // It is an error to invoke a method with the wrong arg types. ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException(\"Argument count (\" + argumentCount + \") doesn't match expected count (\" + handlers.length + \")\"); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]); &#125; return callFactory.newCall(requestBuilder.build());&#125; parseResponse调用OKHttp的execute发送网络请求，根据网络请求结果再进行结果解析 12345678910111213141516171819202122232425262728293031Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125;&#125; 先对响应码进行处理，再通过serviceMethod.toResponse选择数据转换器，对数据进行解析后，生成Response对象返回 异步请求异步请求的流程和同步请求一样，就是再回调处理会进行线程切换ExecutorCallbackCall的enqueue方法 1234567891011121314151617181920212223242526@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;);&#125; 代理执行加入了线程切换到逻辑，通过callbackExecutor切换到主线程OKHttpCall的enqueue方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; throwIfFatal(t); failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;);&#125; 如果使用到RxJava，在上一节已经提到， adapt会进行适配，RxJava2CallAdapter的adapt方法中有对RxJava转换，具体逻辑实现这边先不展开 123Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Retrofit中的HTTP实现Retrofit真正请求网络，底层使用的是OKHttp，Refrofit主要负责网络请求接口的封装，看下源码中与HTTP相关的注解这些注解都是在接口上的声明，主要是HTTP的请求方法和参数，具体可以参考Android网络编程-HTTP/HTTPS，这里也不具体展开了 设计模式应用我们再回顾下这张流程图: 构建者模式这个模式运用的比较多，Retrofit的Builder，ServiceMethod的Builder等设计模式可以参考建造者模式（Bulider模式）详解 工厂模式在Retrofit 初始化，addCallAdapterFactory中的CallAdapter就是用工厂方法模式 12345678910111213141516public interface CallAdapter&lt;R, T&gt; &#123; Type responseType(); T adapt(Call&lt;R&gt; call); abstract class Factory &#123; public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; 实现Factory中抽象方法get，就会返回不同的 CallAdapter 对象设计模式可以参考工厂方法模式（详解版） 外观模式(门面模式)Retrofit 就是一个典型的外观类，它屏蔽了所有的实现细节，提供给使用者方便的接口，统一调用创建接口实例和网络请求配置的方法设计模式可以参考外观模式（Facade模式）详解 策略模式主要应用CallAdapter类的adapt方法，在 Retrofit addCallAdapterFactory，对应 Factory 生成不同的CallAdapter，adapt就可以调用到不同实现CallAdapter就是一个Strategy，Retrofit 对应上下文(Context)设计模式可以参考策略模式（策略设计模式）详解 适配器模式还是在CallAdapter得到应用，Retrofit可以适配Android，Java8，RxJava,guava等平台， 不同平台有不同的特性，addCallAdapterFactory可以生成不同的平台的CallAdapter，把不同平台的特性，统一在一个接口中设计模式可以参考适配器模式（Adapter模式）详解 代理模式Retrofit实例的create方法，使用了动态代理模式，网络请求接口，都会调用到Proxy.newProxyInstance的 invoke 方法中 12345678910111213141516171819202122232425public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); &#125; &#125;);&#125; 除了使用动态代理，Retrofit 还使用了静态代理模式，ExecutorCallbackCall的delegate，在发送请求和接收响应的过程中，增加了一些额外逻辑 @Override public void enqueue(final Callback&lt;T&gt; callback) { checkNotNull(callback, \"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() { @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) { callbackExecutor.execute(new Runnable() { @Override public void run() { if (delegate.isCanceled()) { // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); } else { callback.onResponse(ExecutorCallbackCall.this, response); } } }); } @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) { callbackExecutor.execute(new Runnable() { @Override public void run() { callback.onFailure(ExecutorCallbackCall.this, t); } }); } }); } 设计模式可以参考代理模式（代理设计模式）详解Retrofit使用了大量的设计模式，上面只是在主流过程使用到的，其他设计模式的应用，大家可以继续深入源码去分析，总之，Refrofit框架是非常值得深入研究的框架 参考 Retrofit官网 Android：手把手带你深入剖析 Retrofit 2.0 源码 拆轮子系列：拆 Retrofit Retrofit分析-漂亮的解耦套路 Retrofit2 源码解析之动态代理 Retrofit分析-经典设计模式案例","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yeungeek.github.io/tags/Retrofit/"}]},{"title":"Android网络编程-OKHttp源码角度分析Http","slug":"Network-OKHttp","date":"2019-07-17T14:09:07.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/07/17/Network-OKHttp/","link":"","permalink":"http://yeungeek.github.io/2019/07/17/Network-OKHttp/","excerpt":"前面介绍了网络的基础知识，这篇主要从OKHttp源码角度来分析Http。OKHttp是一个优秀的网络请求框架，有以下特点： 支持HTTP2/SPDY Socket自动选择最好路线，并支持自动重连 拥有自动维护的Socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩） 实现基于Headers的缓存策略","text":"前面介绍了网络的基础知识，这篇主要从OKHttp源码角度来分析Http。OKHttp是一个优秀的网络请求框架，有以下特点： 支持HTTP2/SPDY Socket自动选择最好路线，并支持自动重连 拥有自动维护的Socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩） 实现基于Headers的缓存策略 基本使用同步请求同步的Get请求 1234567OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();Response response = client.newCall(request).execute();return response.body().string(); 异步请求异步的Get请求 1234567891011121314151617OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.e(\"DEBUG\", \"##### onFailure: \", e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(\"DEBUG\", \"##### response: \" + response.body().string()); &#125; &#125;); 源码分析我们从OKHttp的初始化开始分析。 OkHttpClient新建一个OkHttpClient对象 1OkHttpClient client = new OkHttpClient(); 构造函数声明： 123public OkHttpClient() &#123; this(new Builder());&#125; Builder模式构造： 1234567891011121314151617181920212223242526public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); if (proxySelector == null) &#123; proxySelector = new NullProxySelector(); &#125; cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0;&#125; 声明了很多属性，具体含义，等后面用到在具体介绍。 请求流程请求流程可分为同步和异步，大体的请求流程如下图所示： 同步请求流程1client.newCall(request).execute(); newCall返回的是RealCall，上面代码实际上执行的是RealCall的execute方法。 1234567891011121314@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; transmitter.timeoutEnter(); transmitter.callStart(); try &#123; client.dispatcher().executed(this); return getResponseWithInterceptorChain(); &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; executed判断Call对象是否已经执行，每个Call对象只能执行一次 client.dispatcher()返回Dispatcher对象，任务核心调度类，是OKHttp中最重要类之一, executed方法把该线程添加到同步线程队列 123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; getResponseWithInterceptorChain()获取HTTP请求结果，并会进行一系列拦截操作 client.dispatcher().finished(this)执行完毕操作 123void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; 执行完毕后，会把线程从同步线程队列中移除： 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; //异步方法中调用 boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 异步请求流程RealCall的enqueue方法： 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; transmitter.callStart(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; executed含义和同步请求一样，表示请求只能执行一次 client.dispatcher().enqueue(new AsyncCall(responseCallback));，会生成一个AsyncCall对象，并把它加入到readyAsyncCalls线程队列中，等待执行 AsyncCall是RealCall的内部类，并且是NamedRunnable线程类，具体执行方法： 123456789101112131415161718@Override protected void execute() &#123; boolean signalledCallback = false; transmitter.timeoutEnter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; getResponseWithInterceptorChain()获取HTTP请求结果，并会进行一系列拦截操作 client.dispatcher().finished(this);这个方法很重要，和同步方法中调用类似，但是异步的流程则完全不同 finish方法： 1234void finished(AsyncCall call) &#123; call.callsPerHost().decrementAndGet(); finished(runningAsyncCalls, call);&#125; 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; //异步方法中调用 boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 异步流程中，promoteAndExecute方法： 12345678910111213141516171819202122private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; 会遍历异步等待线程队列，并对正在执行的异步线程队列进行最大请求size，以及每个host最大请求size进行检查。把异步等待线程放到正在执行线程队列中，并在等待线程队列中删除该线程，这样就把等待线程变成正在执行线程。 Dispatcher任务调度核心类，这个类，其实在同步和异步请求流程中已经介绍过，其最重要功能是负责请求的分发。Dispatcher在OKHttpClient的Builder中被初始化： 1234public Builder() &#123; dispatcher = new Dispatcher(); .....&#125; 1234567891011private int maxRequests = 64;private int maxRequestsPerHost = 5;private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); maxRequests：最大请求并发请求数64 maxRequestsPerHost：每个主机的最大请求数5 executorService：线程池 readyAsyncCalls：异步等待线程队列 runningAsyncCalls：正在运行的异步线程队列 runningSyncCalls：正在运行的同步线程队列 线程池executorService的声明： 1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService;&#125; 核心线程数为0，表示线程在空闲时不会被保留，等待一段时间后停止 最大线程数Integer.MAX_VALUE，基本上就是可以创建线程无上限 keepAliveTime为60s，表示如果线程空闲时，最多只能存活60s 综合上诉，在OKHttp中，设置了不设上限的线程，不保留最小线程，线程空闲时，最大存活时间为60s，保证I/O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。并通过maxRequests和maxRequestsPerHost来控制并发最大请求数。 拦截器在同步和异步请求中，具体的执行过程中都会调用到getResponseWithInterceptorChain方法，该方法添加了一系列的拦截器，它在OKHttp整理流程中处于非常重要的地位， 方法实现： 1234567891011121314151617181920212223242526272829303132Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try &#123; Response response = chain.proceed(originalRequest); if (transmitter.isCanceled()) &#123; closeQuietly(response); throw new IOException(\"Canceled\"); &#125; return response; &#125; catch (IOException e) &#123; calledNoMoreExchanges = true; throw transmitter.noMoreExchanges(e); &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null); &#125; &#125;&#125; 默认添加的拦截器： RetryAndFollowUpInterceptor：负责失败重试以及重定向 BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应 CacheInterceptor：负责读取缓存直接返回、更新缓存 ConnectInterceptor：负责和服务器建立连接 CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据 这是典型的责任链模式，通过Interceptor，把Request转换为Response，每个Interceptor都有各自的责任和逻辑。 12345interceptors.addAll(client.interceptors());......if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; 开发者可以自己定义Interceptor，在最开始或者发送请求前，对Request和Response进行处理。 HTTP实现OKHttp中实现HTTP主要是在ConnectInterceptor和CallServerInterceptor。 ConnectInterceptor建立服务器之间的连接，CallServerInterceptor发送请求和读取响应。OKHttp请求一个URL的流程： 根据请求的URL，createAddress方法会创建一个Address，用于连接服务器 检查address和routes，是否可以从ConnectionPool获取一个连接 如果没有获取到连接，会进行下一个路由选择(routeSelector)，并且重新尝试从ConnectionPool获取一个连接。重试还是获取不到，就会重新创建一个连接(RealConnection) 获取连接后，它会与服务器建立一个直接的Socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接 发送HTTP请求，并获取响应 ConnectInterceptor在请求发送前的逻辑，都是ConnectInterceptor中实现，ConnectInterceptor的intercept，这个是3.14.2版本源码，和以前多版本稍微有些区别。 123456789@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); Transmitter transmitter = realChain.transmitter(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); return realChain.proceed(request, transmitter, exchange);&#125; Exchange可以传输HTTP请求和响应，并管理连接和事件。newExchange方法调用： 12345678910111213141516/** Returns a new exchange to carry a new request and response. */Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; synchronized (connectionPool) &#123; if (noMoreExchanges) &#123; throw new IllegalStateException(\"released\"); &#125; if (exchange != null) &#123; throw new IllegalStateException(\"cannot make a new request because the previous response \" + \"is still open: please call response.close()\"); &#125; &#125; ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks); Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec); ...... &#125;&#125; find方法会最终执行ExchangeFinder的findConnection方法，在发送HTTP请求之前的逻辑，都是这个方法中实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; RealConnection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); ...... if (result == null) &#123; //2.根据 Address 从连接池获取连接 // Attempt to get a connection from the pool. if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123; foundPooledConnection = true; result = transmitter.connection; &#125; else if (nextRouteToTry != null) &#123; selectedRoute = nextRouteToTry; nextRouteToTry = null; &#125; else if (retryCurrentRoute()) &#123; selectedRoute = transmitter.connection.route(); &#125; &#125; &#125; ...... // 3. 重新选择路由 // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; List&lt;Route&gt; routes = null; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. routes = routeSelection.getAll(); if (connectionPool.transmitterAcquirePooledConnection( address, transmitter, routes, false)) &#123; foundPooledConnection = true; result = transmitter.connection; &#125; &#125; if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // 3. 重新选择路由，创建新的 `RealConnection` // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. result = new RealConnection(connectionPool, selectedRoute); connectingConnection = result; &#125; &#125; ...... // 4. 进行 Socket 连接 // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); connectionPool.routeDatabase.connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; connectingConnection = null; // Last attempt at connection coalescing, which only occurs if we attempted multiple // concurrent connections to the same host. if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123; // We lost the race! Close the connection we created and return the pooled connection. result.noNewExchanges = true; socket = result.socket(); result = transmitter.connection; &#125; else &#123; //把连接放入连接池中 connectionPool.put(result); transmitter.acquireConnectionNoEvents(result); &#125; &#125; ...... return result;&#125; HTTP 的连接主要是result.connect方法： 12345678910111213141516171819202122232425public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener)&#123; if (protocol != null) throw new IllegalStateException(\"already connected\"); ...... while (true) &#123; try &#123; if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123; connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol); break; &#125; catch (IOException e) &#123; ...... &#125; &#125; ......&#125; 在 for 循环中检查这个连接是否是隧道协议连接。connectSocket连接socket，establishProtocol根据HTTP协议版本进行连接处理。重点分析下connectSocket方法： 123456789101112131415161718192021private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123; ...... try &#123; //连接 socket Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; catch (ConnectException e) &#123; ConnectException ce = new ConnectException(\"Failed to connect to \" + route.socketAddress()); ce.initCause(e); throw ce; &#125; try &#123; source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; catch (NullPointerException npe) &#123; if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123; throw new IOException(npe); &#125; &#125;&#125; 使用 Okio，封装了Socket的读写操作， 建立连接后，就可以发送请求和获取响应。 CallServerInterceptorCallServerInterceptor的intercept()方法里负责发送请求和获取响应。具体操作都是通过Exchange来执行，Exchange通过各个功能模块再进行分发处理。通过 Socket 发送 HTTP消息，会按照以下声明周期： writeRequestHeaders发送 request Headers 如果有 request body，就通过 Sink 发送request body，然后关闭 Sink readResponseHeaders获取 response Headers 通过Source读取 response body，然后关闭 Source writeRequestHeadersExchange 调用writeRequestHeaders方法 1234567891011public void writeRequestHeaders(Request request) throws IOException &#123; try &#123; eventListener.requestHeadersStart(call); codec.writeRequestHeaders(request); eventListener.requestHeadersEnd(call, request); &#125; catch (IOException e) &#123; eventListener.requestFailed(call, e); trackFailure(e); throw e; &#125; &#125; 实际执行的方法codec实现类Http1ExchangeCodec(前面根据HTTP协议版本选择)的writeRequest方法 12345678910111213/** Returns bytes of a request header for sending on an HTTP transport. */public void writeRequest(Headers headers, String requestLine) throws IOException &#123; if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state); sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(\": \") .writeUtf8(headers.value(i)) .writeUtf8(\"\\r\\n\"); &#125; sink.writeUtf8(\"\\r\\n\"); state = STATE_OPEN_REQUEST_BODY;&#125; readResponseHeaders读取响应头部，Http1ExchangeCodec的readResponseHeaders方法： 1234567891011121314151617181920212223242526272829@Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; if (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123; throw new IllegalStateException(\"state: \" + state); &#125; try &#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message) .headers(readHeaders()); if (expectContinue &amp;&amp; statusLine.code == HTTP_CONTINUE) &#123; return null; &#125; else if (statusLine.code == HTTP_CONTINUE) &#123; state = STATE_READ_RESPONSE_HEADERS; return responseBuilder; &#125; state = STATE_OPEN_RESPONSE_BODY; return responseBuilder; &#125; catch (EOFException e) &#123; // Provide more context if the server ends the stream before sending a response. String address = \"unknown\"; if (realConnection != null) &#123; address = realConnection.route().address().url().redact(); &#125; throw new IOException(\"unexpected end of stream on \" + address, e); &#125;&#125; StatusLine解析HTTP版本信息，readHeaders()读取response header 信息。 123456789/** Reads headers or trailers. */private Headers readHeaders() throws IOException &#123; Headers.Builder headers = new Headers.Builder(); // parse the result headers until the first blank line for (String line; (line = readHeaderLine()).length() != 0; ) &#123; Internal.instance.addLenient(headers, line); &#125; return headers.build();&#125; response body解析 response body 内容： 12345678910if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build();&#125; else &#123; response = response.newBuilder() .body(exchange.openResponseBody(response)) .build();&#125; 如果不是websocket，调用Exchange的openResponseBody方法： 1234567891011121314public ResponseBody openResponseBody(Response response) throws IOException &#123; try &#123; eventListener.responseBodyStart(call); String contentType = response.header(\"Content-Type\"); long contentLength = codec.reportedContentLength(response); Source rawSource = codec.openResponseBodySource(response); ResponseBodySource source = new ResponseBodySource(rawSource, contentLength); return new RealResponseBody(contentType, contentLength, Okio.buffer(source)); &#125; catch (IOException e) &#123; eventListener.responseFailed(call, e); trackFailure(e); throw e; &#125;&#125; 获取返回的 body，通过 Source 转换为需要的数据类型，ResponseBody提供的 string()，转换为 String 类型 123456public final String string() throws IOException &#123; try (BufferedSource source = source()) &#123; Charset charset = Util.bomAwareCharset(source, charset()); return source.readString(charset); &#125;&#125; 通过上述的分析，OKHttp是通过Okio操作Socket实现了Http协议，凭借高效的性能，Android系统从4.4版本开始，HTTP的实现已经替换为OKHttp。 参考 OKHttp源码解析(一)–初阶 拆轮子系列：拆 OkHttp","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://yeungeek.github.io/tags/OKHttp/"}]},{"title":"Android网络编程-Cookie，Session，Token","slug":"Network-Cookie-Session-Token","date":"2019-07-15T23:04:35.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/07/15/Network-Cookie-Session-Token/","link":"","permalink":"http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/","excerpt":"HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。","text":"HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。 CookieCookie机制是在客户端实现，采用客户端保持状态的方案。Cookie由服务端生成，发送给客户端(Set-Cookie)，客户端请求的时候会带上这个Cookie。请求流程：Cookie字段：名字、值、过期时间、路径和域。路径与域一起构成Cookie的作用范围。通过Chrome的开发者工具中看到，在github.com上保存在客户端的Cookie信息。 Name：名字 Value：值 Domain：域 Path：路径 Expaires/Max-Age：过期时间 上图中logged_in和user_session两个Cookie值表示登录github.com后保存下来的登录状态和Session。 SessionSession是在服务端实现，当客户端请求服务端时，服务端会检查请求中是否包含Session标识(Session id)， 如果没有,那么服务端就生成一个随机的Session以及和它匹配的Session id,并将Session id返回给客户端。 如果有,那么服务器就在存储中根据Session id 查找到对应的Session。 TokenToken也称作令牌，由uid+time+sign[+固定参数]组成: uid：用户唯一身份标识 time：当前时间的时间戳 sign：签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器 以下几点特性会让你在程序中使用基于Token的身份验证： 无状态、可扩展 支持移动设备 跨程序调用 安全 Token是有客户端来保存，用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。而认证的具体流程如下： 客户端使用用户名跟密码请求登录服务端收到请求，去验证用户名与密码验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 第三方授权登录这是Token的一种应用场景，使用OAuth实现。OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。我们看下github的授权流程： 图片来源：github 授权登录教程与如何设计第三方授权登录的用户表 区别Cookie和Session 维度 Cookie Sesson 存放位置 客户端 服务端 存取方式 只能保管ASCII字符串 任何类型的数据 安全性 对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容 对客户端是透明的，不存在敏感信息泄露的风险 有效期 可以保持很长时间不过期 依赖于JSESSIONID的Cookie，默许过期时间为–1，只需关闭了浏览器，该Session就会失效 跨域支持 支持跨域名访问 仅在它所在的域名内有效 Token和Session作为身份认证Token安全性比Session好。Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Token,如果指的是OAuth Token 或类似的机制的话，提供的是认证和授权 ，认证是针对用户，授权是针对App。 参考 Cookie、Session、Token那点事儿 彻底理解cookie，session，token 精读《图解HTTP》","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Session","slug":"Session","permalink":"http://yeungeek.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yeungeek.github.io/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"http://yeungeek.github.io/tags/Token/"}]},{"title":"Android网络编程-HTTP/HTTPS","slug":"Network-Http","date":"2019-07-12T10:09:56.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/07/12/Network-Http/","link":"","permalink":"http://yeungeek.github.io/2019/07/12/Network-Http/","excerpt":"HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP/IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。","text":"HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP/IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。这是最基本的HTTP工作原理，如图所示: HTTP报文HTTP属于应用层，应用层传输的数据单位是报文。HTTP报文分为请求报文和响应报文。 请求报文HTTP请求报文由以下4个部分组成: 请求行：请求类型,要访问的资源以及所使用的HTTP版本。 请求头部：服务器要使用的附加信息。 空行：请求头部后面的空行是必须的 请求包体：可以添加任意的其他数据 请求行请求行组成：请求方法，请求URL，协议版本。 请求方法 方法 作用 说明 GET 获取资源 用来请求访问已被URI标识的 POST 传输实体主体 POST主要用来传输数据，而GET主要用来获取资源 HEAD 获取报文首部 和GET方法类似，但是不返回报文实体主体部分 PUT 上传文件 用来传输文件，由于自身不带验证机制，任何人都可以上传文件 DELETE 删除文件 与PUT功能相反，并且同样不带验证机制 OPTIONS 查询支持的方法 用来查询针对请求URI请求的资源支持的方法 TRACE 追踪路径 服务器会将通信路径返回给客户端 CONNECT 要求用隧道协议连接代理 使用 SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输 请求URLURL(Uniform Resource Locator)统一资源定位符，表示资源的地点(互联网上的地址)。URI(Uniform Resource Identifier)统一资源标识符，用字符串标识某一互联网资源，URL是URI的子集。 协议版本 HTTP/1.0：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用 HTTP/1.1：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 HTTP/2.0：HTTP 2.0是下一代HTTP协议，目前应用还非常少 请求头部请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。有4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段，所有完整首部这里我们先了解下常用的请求首部。 字段 说明 Accept 用户代理可处理的媒体类型 Accept-Encoding 优先的内容编码Accept-Encoding: gzip, deflate, br Authorization Web 认证信息 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Content-Encoding 实体主体适用的编码方式 Content-Type 实体主体的媒体类型 Content-Length 实体主体的大小 Host 请求资源所在服务器 If-Modified-Since 服务器上次返回的Last-Modified日期，如果在这个日期之后，请求的资源都没有更新过，则返回304 Not Modified响应 If-None-Match 比较实体标记，值为上一次返回的ETag，一般会和If-Modified-Since一起返回 Referer 对请求中URI的原始获取方 User-Agent HTTP 客户端程序的信息 Cookie 保存状态信息 Transfer-Encoding 指定报文主体的传输编码方式 请求包体请求包体不在 GET 方法中使用，而是在POST 方法中使用。HTTP请求的请求体有三种不同的形式： 任意类型：服务器不会解析请求体，请求体的处理需要自己解析，比如JSON 键值对(application/x-www-form-urlencoded)：最常见的 POST 提交数据的方式，表单模式 文件分割：请求体被分成为多个部分，文件上传时会被使用 示例使用抓包工具或者Chrome来查看 123456789POST /getconfig HTTP/1.1Content-Type: application/x-www-form-urlencodedUser-Agent: Dalvik/2.1.0 (Linux; U; Android 9; Redmi Note 7 MIUI/V10.3.2.0.PFGCNXM)Host: data.mistat.xiaomi.comAccept-Encoding: gzipContent-Length: 205Connection: closeapp_id=1000274&amp;app_version=10.8.3 请求行：显示Post请求，协议版本为HTTP/1.1 请求头部：Content-Type,User-Agent,Host,Accept-Encoding,Content-Length,Connection 请求体：Content-Type声明为键值对 响应报文HTTP 响应报文由状态行、响应头部、空行和响应包体4个部分组成。 状态行状态行由HTTP协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;协议版本和请求中的对应，状态码和描述会一一对应。 状态码、描述状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类： 1xx：Informational（信息性状态码），接收的请求正在处理; 2xx：Success（成功状态码），请求正常处理完毕; 3xx：Redirection（重定向状态码），需要进行附加操作以完成请求; 4xx：Client Error（客户端错误状态码），服务器无法处理请求; 5xx：Server Error（服务器错误状态码），服务器处理请求出错; 常用的一些状态码和描述 1xx 状态码、描述 说明 100 Continue 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2xx 状态码、描述 说明 200 OK 请求成功 204 No Content 请求已经成功处理，但是返回的响应报文不包含实体的主体部分 206 Partial Content 表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容 3xx 状态码、描述 说明 301 Moved Permanently 永久性重定向 302 Found 临时性重定向 304 Not Modified 如果请求报文首部包含一些条件，If-Match，If-Range, If-Modified-Since，If-None-Match，，If-Unmodified-Since。如果不满足条件，则服务器会返回 304 状态码 307 Temporary Redirect 临时重定向，与 302 的含义类似，但是307要求浏览器不会把重定向请求的POST方法改成GET方法 4xx 状态码、描述 说明 400 Bad Request 请求报文中存在语法错误 401 Unauthorized 请求需要验证用户 403 Forbidden 访问权限问题 404 Not Found 5xx 状态码、描述 说明 500 Internal Server Error 服务器正在执行请求时发生错误 503 Service Unavailable 服务器正在执行请求时发生错误 响应头部和请求头部一样，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。常用的请求首部 字段 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Transfer-Encoding 指定报文主体的传输编码方式 Content-Encoding 实体主体适用的编码方式 Content-Type 实体主体的媒体类型 Content-Length 实体主体的大小 Expires 实体主体过期的日期时间 ETag 资源的匹配信息，和If-Nome-Match对应 Date 服务端 Location 令客户端重定向至指定 URI Server HTTP 服务器的安装信息 Last-Modified 资源的最后修改日期时间 Set-Cookie 设置Cookie，客户端得到响应报文后把 Cookie 内容保存到浏览器中 其他更详细的首部信息，可以参考这里 响应包体服务器返回给客户端的文本信息。和请求包体的分类一样。 示例12345678HTTP/1.1 200 OKDate: Sat, 13 Jul 2019 08:40:52 GMTContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedContent-Encoding: gzipConnection: close&#123;\"errorCode\":-2,\"reason\":\"no changing\",\"result\":null&#125; 响应行：返回响应码200 Ok，表示服务端返回数据成功 响应头部：Content-Type设置返回的类型为JSON格式 响应包体：返回具体JSON数据 HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 与HTTP区别 协议 原理 数据格式 传输速度 端口 HTTP 应用层 明文传输 三次握手，传输三个包 80 HTTPS 传输层 SSL加密 三次握手基础上增加ssl握手(9个包)，传输12个包 443 缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 HTTP框架VolleyVolley是Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持OKHttp。 OKHttpOKHttp是Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步。已被谷歌加入到Android的源码中。 RetrofitRetrofit是Square公司出品的默认基于OKHttp 封装的一套 RESTful 网络请求框架 后续文章会从OKHttp、Retrofit角度来分析Http。 参考 Http 这是一份全面&amp; 详细 HTTP协议 学习攻略 精读《图解HTTP》 HTTP 协议入门","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"Https","slug":"Https","permalink":"http://yeungeek.github.io/tags/Https/"}]},{"title":"Android网络编程-Socket","slug":"Network-Socket","date":"2019-06-26T20:18:07.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/06/26/Network-Socket/","link":"","permalink":"http://yeungeek.github.io/2019/06/26/Network-Socket/","excerpt":"Socket在Android网络编程中，有着非常重要的作用。 Socket基本概念即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。","text":"Socket在Android网络编程中，有着非常重要的作用。 Socket基本概念即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 借用下网上结构图:IP地址和端口号组成了Socket，都是成对出现。 1Socket =&#123;(IP地址1:PORT端口号)，(IP地址2:PORT端口号)&#125; 单独的Socke是没用任何作用的,基于一定的协议（TCP或者UDP）下的Socket编程才能进行数据传输。 Socket工作流程服务端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。客户端初始化一个socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务端的连接就建立了。客户端发送数据请求，服务端接收请求并处理请求，然后把回应数据发给客户端，客户端读取数据，最后关闭数据，一次交互结束。 分类Socket使用类型有两种： 基于TCP协议，流套接字，采用流的方式提供可靠的字节流服务 基于UDP协议，数据报套接字，采用数据报文提供数据打包发送的服务 基于TCP的Socket编程主要APISocket构造方法12public Socket(String host, int port) throws UnknownHostException, IOException 创建流套接字并将其连接到指定主机上的指定端口号。 host: 主机地址 port: 端口号 getInputStream返回Socket的输入流，用户接受数据。 getOutputStream返回Socket的输出流，用于发送数据。 ServerSocketSocket的服务端实现 构造函数1public ServerSocket(int port) throws IOException 创建服务端Socket，绑定到指定端口。 port: 端口号 accept1public Socket accept() throws IOException 监听并接受到此套接字的连接。该方法将阻塞，直到建立连接。 示例服务端1234567891011121314151617181920212223242526272829public class Server &#123; public static void main(String[] args) throws IOException &#123; //1. 创建ServerSocket ServerSocket serverSocket = new ServerSocket(8888); //2. 监听 Socket socket = serverSocket.accept(); System.out.println(\"server start listen\"); //3. 输入流 InputStream is = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(is); BufferedReader br = new BufferedReader(reader); String content = null; StringBuffer sb = new StringBuffer(); while ((content = br.readLine()) != null) &#123; sb.append(content); &#125; System.out.println(\"server receiver: \" + sb.toString()); socket.shutdownInput(); br.close(); reader.close(); is.close(); socket.close(); serverSocket.close(); &#125;&#125; 非常简单的Socket服务端，接收到客户端的数据，就会关闭当前的连接。这个示例只是展示了一个完整的流程。如果需要复杂的服务端实现，可以使用Netty、Mina或者其他Socket框架。 客户端12345678910111213//1. 创建客户端Socket socket = new Socket(\"your ip\", 8888);//2. 输出流OutputStream os = socket.getOutputStream();//3. 发送数据os.write(\"Hello world\".getBytes());System.out.println(\"send message\");os.flush();socket.shutdownOutput();os.close();socket.close(); 客户端就是连接后，发送了一份数据，就关闭连接了。这样就实现了客户端和服务端的通信。 基于UDP的Socket编程主要APIDatagramPacket用来包装接收和发送的数据。 构造接收数据包 1public DatagramPacket(byte[] buf,int length) 用来接收长度为 length 的数据包。 构造发送数据包 12DatagramPacket(byte[] buf, int length,SocketAddress address)DatagramPacket(byte[] buf, int length, InetAddress address, int port) 用来将长度为 length 的包发送到指定主机上的指定端口号。 DatagramSocket用来发送和接收数据报包的套接字。 构造方法12345//创建数据报套接字并将其绑定到本地主机上的指定端口DatagramSocket(int port) //创建数据报套接字，将其绑定到指定的本地地址DatagramSocket(int port, InetAddress laddr) 发送数据1void send(DatagramPacket p) DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号 接收数据1void receive(DatagramPacket p) 当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。 示例服务端1234567891011121314151617181920public class UDPServer &#123; public static void main(String[] args) throws IOException &#123; byte[] buf = new byte[1024]; // receive // 1.create DatagramPacket packet = new DatagramPacket(buf, buf.length); // 2.create udp socket DatagramSocket socket = new DatagramSocket(8888); // 3. receive start socket.receive(packet); // 4. receive data System.out.println(\"sever: \" + new String(buf, 0, buf.length)); // send DatagramPacket p = new DatagramPacket(buf, buf.length, packet.getAddress(), packet.getPort()); socket.send(p); socket.close(); &#125;&#125; 客户端12345678910111213141516// sendInetAddress address = InetAddress.getByName(\"your ip\");//1.create packetDatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, 8888);//2.create socketDatagramSocket socket = new DatagramSocket();//3.send datasocket.send(packet);// receive//1.create packetfinal byte[] bytes = new byte[1024];DatagramPacket receiverPacket = new DatagramPacket(bytes, bytes.length);socket.receive(receiverPacket);System.out.println(\"client: \" + new String(bytes, 0, bytes.length));socket.close(); 客户端和服务端的实现，都比较简单。 关于Socket编程，就介绍好了，这篇只是开了头，最主要的还是得去项目中实践。 参考 Android：这是一份很详细的Socket使用攻略 Scoket编程","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Socket","slug":"Socket","permalink":"http://yeungeek.github.io/tags/Socket/"}]},{"title":"Android网络编程-TCP/IP协议","slug":"Network-TCP-IP","date":"2019-06-21T11:28:07.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/06/21/Network-TCP-IP/","link":"","permalink":"http://yeungeek.github.io/2019/06/21/Network-TCP-IP/","excerpt":"在Android网络编程-计算机网络基础一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。","text":"在Android网络编程-计算机网络基础一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。 数据报文在不同层传输的数据单位名称不同，在网络层传输的叫数据报，在传输层传输的叫报文段。 IP数据报IP数据报格式如下图:各个字段的详细说明： 名称 长度 说明 版本 4bit IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6 首部长度 4bit IP报头的长度，最大长度60字节(15*4)，分为固定部分的长度(20字节)和可变部分的长度 服务类型 8bit Type Of Service 总长度 16bit IP报文的总长度。数据报的最大长度为 65535 字节 标识 16bit 它是一个计数器，用来产生数据报的标识。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，此标识表示同一个数据报的分片。 标志 3bit R、DF、MF三位，目前只有后两位有效。DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。 片偏移 13bit 本分片在原先数据报文中相对首位的偏移位。片偏移以8个字节为偏移单位。 生存时间 8bit TTL (Time To Live)表示数据报在网络中的寿命，其单位为秒。在目前的实际应用中，常以“跳”为单位。 协议 8bit 指出IP报文携带的数据使用的哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2. 首部校验和 16bit 计算IP头部的校验和，检查IP报头的完整性。 源地址 32bit 标识IP数据报的源端设备。 目的地址 32bit 标识IP数据报的目的地址。 可选字段 长度可变 1～40 字节，用于增加IP数据报的控制功能。 填充 保证IP首部长度是4字节的整倍数 TCP报文 名称 长度 说明 源端口 16bit 数据发送方的端口号 目的端口 16bit 数据接受方的端口号 序号 32bit 本数据报文中的的第一个字节的序号(在数据流中每个字节都对应一个序号) 确认号 32bit 希望收到的下一个数据报文中的第一个字节的序号 数据偏移 4bit 表示本报文数据段距离报文段有多远 保留字段 6bit 保留为今后使用，但目前应置为0 紧急比特URG 当值为1时表示次报文段中有需要紧急处理 确认比特ACK 值为1时确认号有效，值为0时确认号无效 复位比特RST 值为1时表示TCP连接存在严重的错误，需要重新进行连接 同步比特SYN 值为1表示这是一个连接请求或连接接受报文 终止比特FIN 值为1表示要发送的数据报已经发送完毕，需要释放传送连接 窗口 16bit TCP连接的一端根据缓存空间的大小来确定自己接受窗口的大小限制发送放的窗口上限 检验和 16bit 用来检验首部和数据两部分的正确性 紧急指针字段 16bit 紧急指针指出在本报文段中的紧急数据的最后一个字节的序号 选项字段 长度可变 TCP 首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项 UDP报文相对于TCP报文，UDP报文简单了很多。 名称 长度 说明 源端口 16bit 数据发送方的端口号 目的端口 16bit 数据接受方的端口号 包长度 16bit UDP首部的长度和数据的长度之和。单位为字节 校验和 16bit 用来检验首部和数据两部分的正确性 TCP三次握手和四次挥手TCP用三次握手来创建连接，使用四次分手来释放连接。 三次握手三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小的信息。握手过程： 第一次握手：建立连接，客户端先发送连接请求报文，将SYN设置为1，Sequence Number为x。客户端进入SYN+SEND状态，等待服务器确认。 第二次握手：服务器收到SYN报文。服务器收到客户端的SYN报文，需要对这个SYN报文进行确认，设置Acknowledgment Number为x+1(Sequence+1)；同时，自己还要送法SYN消息，将SYN位置为1，Sequence Number为y；服务器将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN+RECV状态。 第三次握手：客户端收到服务器的 SYN+ACK报文段。然后将Acknowlegment Number设为y+1,向服务器发送ACK报文段，这个报文段发送完毕后，客户端端服务器都进入ESTABLISHED状态，完成TCP三次握手。 完成了三次握手，客户端和服务器就可以开始传送数据了。 四次挥手当客户端和服务端传输数据完毕后，需要断开TCP连接。TCP断开的过程，就是四次挥手。 第一次挥手：客户端(也可以是服务器)，设置Sequence Number和Acknowledgment Number，向服务器发送一个FIN报文段。此时客户端进入FIN_WAIT_1状态；这表示客户端没有数据发送给主机了。 第二次挥手：服务器收到客户端发来的FIN报文段，向客户端回一个ACK报文段，Acknowledgement Number为Sequence Number加1；客户端进入FIN_WAIT_2状态，服务器进入CLOSE_WAIT状态；服务器告诉客户端，我同意你的”关闭”请求。 第三次挥手：服务器向客户端发送FIN报文段，请求关闭连接，同时服务器进入LAST_ACK状态。 第四次挥手：客户端收到服务器发送的FIN报文段，向主机发送ACK报文段，然后客户端进入TIME_WAIT状态，服务器收到客户端的ACK报文段以后，就关闭连接，此时，客户端等待2MSL后一次没有到收到回复，则证明服务端已正常关闭，那好，客户端也可以关闭连接了。 TCP三次握手的必要性防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源。 TCP四次挥手的必要性为了保证通信双方都能通知对方，需释放、断开连接。 为什么客户端关闭连接前要等待2MSL时间 MSL: 最大报文段生存时间 四个报文发送完毕后，就可以直接进入CLOSE状态了，但是有可能网络是不可靠的，一切都可能发生，比如有可能最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。展开具体来讲： 为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接。 防止早已失效的连接请求报文，出现在本连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。 TCP、UDP比较 TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向报文 效率 低效 高效 双工性 全双工 一对一，一对多，多对一，多对多支持多播和广播 流量控制 滑动窗口机制 拥塞控制 慢开始/拥塞避免快重传/快恢复 传输速度 慢 快 应用场景 效率要求相对低，准确要求相对高。要求有连接的场景 效率要求相对高，准确要求相对低 应用 SMTP，TELNET，HTTP，FTP DNS，RIP，NFS，SNMP，IP电话，流媒体 参考 计算机网络：这是一份全面 &amp; 详细 的TCP协议攻略 《图解TCP/IP》读书笔记 Android网络编程：基础理论汇总","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"TCP","slug":"TCP","permalink":"http://yeungeek.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://yeungeek.github.io/tags/UDP/"},{"name":"IP","slug":"IP","permalink":"http://yeungeek.github.io/tags/IP/"}]},{"title":"Android网络编程-计算机网络基础","slug":"Network-Basic","date":"2019-06-14T22:58:01.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/06/14/Network-Basic/","link":"","permalink":"http://yeungeek.github.io/2019/06/14/Network-Basic/","excerpt":"从本篇开始，真正进入我们的Android网络编程学习之旅。 概念计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。","text":"从本篇开始，真正进入我们的Android网络编程学习之旅。 概念计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。 计算机网络体系结构 计算机网络体系结构可以定义为是网络协议的层次划分与各层协议的集合，同一层中的协议根据该层所要实现的功能来确定。各对等层之间的协议功能由相应的底层提供服务完成。—— 百度百科 分层对于复杂的计算机网络协议，结构分层很有必要。就像Android开发中，把应用分层各个模块。 优缺点优点： 各层之间相互独立。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间接口（即界面）所提供的服务 灵活性好。当任何一层发送变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响 结构上可分割开。各层都可以采用最合适的技术来实现 易于实现和维护。 这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统 能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明 缺点：各层之间会有相同的功能出现，产生额外开销。 体系结构目前有3种体系结构: OSI参考模型，概念清楚，理论也较完整，但它既复杂又不实用 TCP/IP体系结构，是一系列网络协议的总称，目前应用最广泛 五层体系结构，综合OSI和TCP/IP的优点,既简洁又能将概念阐述清楚 OSI参考模型 分层 功能 数据单位 协议栈 物理层 屏蔽传输媒体和通信手段的差异 比特(bit) 数据链路层 互连设备之间传送和识别数据帧 帧(frame) 点对点协议以太网协议 高级数据链路协议帧中继 网络层 地址管理和路由选择 数据报(datagram) IP协议路由选择协议 传输层 管理两个节点之间的数据传输 负责可靠传输（确保数据被可靠地传送到目标地址） 报文段(segment) TCP协议UDP协议 会话层 通信管理。负责建立和断开通信连接（数据流动的逻辑通路） 提供了数据交换定界和同步功能 管理传输层一下的分层 表示层 数据压缩、加密以及数据描述 应用层 针对特定应用的协议 报文(message) HTTPDNSFTPSMTPSSH TCP/IPTCP/IP的体系结构比较简单，只有四层。它并不是遵循严格的 OSI 分层概念，应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。可以演化成如下图所示: 五层协议OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层的体系结构。在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 五层协议中各层的主要功能五层协议中，没有表示层和会话层，这两层的功能留给开发者来处理。 物理层在物理层，定义了以下内容： 接口特性 机械特性：规定了接口的几何形状等 电器特性：规定了接口使用的电平大小等 功能特性：规定了接口引脚个数及各项功能等 规程特性：定义了接口在工作过程中遵循的相应过程。 比特编码：用比特对信息按照一定规则进行编码，用于传输 数据率：即数据传输速率 比特同步：时钟同步 通讯方式: 单工通信：单向传输 半双工通信：双向交替传输 双工通信：双向同时传输 数据链路层功能： 负责结点-结点数据传输 组桢：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 物理寻址：在桢头添加发送端或接收端的物理地址标识数据帧的发送端或接收端。 流量控制：匹配发送端与接收端的发送速度与接收速度，避免数据淹没接收端。 差错控制：检测并重传损坏或丢失帧，并避免重复帧。 访问（接入）控制：在任一给定时刻决定哪个设备拥有链路（物理介质）的控制使用权。 网络层功能: 负责源主机到目的主机数据分组（packet）的交付（可能穿越多个网络）。 逻辑寻址：全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址（穿越多个网络时，链路层的物理寻址并不能用）。 路由：路由器（或网关）互连网络，并路由分组至最终目的主机，进行路径选择。 分组转发 传输层传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节。功能: 负责源-目的（端-端）（进程间）完整报文传输 报文分段与重组 SAP寻址：确保将完整报文提交给正确进程，如端口号 连接控制：负责端-端的连接控制（建立连接、拆除连接），是一种逻辑连接 流量控制：控制端-端传输的速度 差错控制：差错检测与纠正 应用层应用层直接为用户的应用进程提供服务 主要协议IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。IP的主要作用就是在复杂的网络环境中将数据包发给最终的目标地址。相关技术： DNS：域名系统，一种分布式的网络目录服务，主要用于域名与IP地址的要互转换。 ARP：ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。不过，ARP只适用于IPv4，不适用于IPv6。 ICMP：Internet控制报文协议，作用是报告一些网络传输过程中的错误与做一些同步工作。 DHCP：动态主机配置协议，实现自动设置IP地址、统一管理IP地址分配。 NAT：网络地址转换，作用是将IP数据报头中的IP地址转换为另一个IP地址。 IP隧道：是一种数据包封装技术，它是将原始IP包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的IP包）的数据净荷中进行传输。 TCP协议传输控制协议(Transmission Control Protocol)，面向连接的、可靠的流协议，提供可靠的通信传输。 UDP协议用户数据报协议(User Datagram Protocol)，面向无连接的，具有不可靠性的数据报协议。 路由协议Routing protocol，是一种指定数据包转送方式的网上协议。 Socket即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。 HTTP协议超文本传输协议(Hyper Text Transfer Protocol)，用于从万维网服务器传输超文本到本地浏览器的传送协议。 系列文章目录 参考 趣谈网络协议 互联网协议入门（一） 《图解TCP/IP》读书笔记 计算机网络 面试带你飞：这是一份全面的 计算机网络基础 总结攻略 计算机网络的体系结构 计算机网络体系结构","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"}]},{"title":"Android网络编程-系列文章","slug":"Network-Series","date":"2019-06-13T23:34:10.000Z","updated":"2020-01-17T03:44:17.195Z","comments":true,"path":"2019/06/13/Network-Series/","link":"","permalink":"http://yeungeek.github.io/2019/06/13/Network-Series/","excerpt":"在Android开发过程中，网络编程是必不可少的。大家接触的Volley,Retrofit,OKHttp等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。","text":"在Android开发过程中，网络编程是必不可少的。大家接触的Volley,Retrofit,OKHttp等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。 本系列会介绍计算机网络的基础、TCP/UDP、Http协议、Socket等，并从源码角度分析Retrofit、OKHttp，它们是如何实现Http的。 千里之行，始于足下。不管何时，我相信，扎实的功底和过硬的技术，都会是你职业发展的助力器。 —- 极客时间《趣谈网络协议》刘超 系列文章目录 01.Android网络编程-计算机网络基础 02.Android网络编程-TCP/IP协议 03.Android网络编程-Socket 04.Android网络编程-HTTP/HTTPS 05.Android网络编程-Cookie，Session，Token 06.Android网络编程-OKHttp源码角度分析Http 07.Android网络编程-Retrofit源码角度分析Http 参考 Android网络编程：基础理论汇总 计算机网络 面试带你飞：这是一份全面的 计算机网络基础 总结攻略 Android网络编程系列","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android应用层/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://yeungeek.github.io/tags/OKHttp/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yeungeek.github.io/tags/Retrofit/"}]}]}