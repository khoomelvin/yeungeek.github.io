<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeungeek</title>
  <icon>https://www.gravatar.com/avatar/0a7bd4cded6dbbd2a98de3e1269895c0</icon>
  <subtitle>Android 沉思录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yeungeek.github.io/"/>
  <updated>2020-01-17T03:44:17.195Z</updated>
  <id>http://yeungeek.github.io/</id>
  
  <author>
    <name>Yeungeek</name>
    <email>yeungeek@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Camera-Camera1使用</title>
    <link href="http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/"/>
    <id>http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/</id>
    <published>2020-01-17T09:32:39.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了<a href="https://github.com/google/cameraview" target="_blank" rel="noopener">CameraView</a>，提供给开发者参考和学习，现在最新的可以使用<a href="https://developer.android.com/jetpack/androidx/releases/camerax" target="_blank" rel="noopener">Jetpack CameraX</a>来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。</p><a id="more"></a><p>相机开发的流程：</p><ol><li>检测设备摄像头，打开相机</li><li>创建预览画面，显示实时预览画面</li><li>设置相机参数，进行拍照监听</li><li>监听中，保存图片资源或者直接操作原始数据</li><li>释放相机资源</li></ol><p>上面的是基本的相机开发流程，不同的Camera API在实现上会有不同，整体流程上还是统一的。  </p><h1 id="Camera1使用"><a href="#Camera1使用" class="headerlink" title="Camera1使用"></a>Camera1使用</h1><h2 id="权限声明"><a href="#权限声明" class="headerlink" title="权限声明"></a>权限声明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.hardware.camera"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>相机必须声明<code>CAMERA</code>权限，在Android6.0上，你还需要在代码中动态申请权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.CAMERA&#125;,</span><br><span class="line">                    REQUEST_CAMERA_PERMISSION);</span><br></pre></td></tr></table></figure><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>下图是一个开发流程的导览：<br><a href="https://imgchr.com/i/lxqhbq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/17/lxqhbq.md.png" alt="Camera1开发流程"></a></p><h3 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Camera.open()</span><br></pre></td></tr></table></figure><p>该方法的系统源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Camera <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numberOfCameras = getNumberOfCameras();</span><br><span class="line">    CameraInfo cameraInfo = <span class="keyword">new</span> CameraInfo();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">        getCameraInfo(i, cameraInfo);</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Camera(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会检查可用的摄像头，默认使用的<code>CameraInfo.CAMERA_FACING_BACK</code>后置摄像头</p><h3 id="创建预览画面"><a href="#创建预览画面" class="headerlink" title="创建预览画面"></a>创建预览画面</h3><p>这里使用的是<code>SurfaceView</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SurfaceView mSurfaceView;</span><br><span class="line"><span class="keyword">private</span> SurfaceHolder mSurfaceHolder;</span><br><span class="line">...</span><br><span class="line">mSurfaceHolder = mSurfaceView.getHolder();</span><br><span class="line">mSurfaceHolder.addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        startPreview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置实时预览</span></span><br><span class="line">        mCamera.setPreviewDisplay(mSurfaceHolder);</span><br><span class="line">        <span class="comment">//Orientation</span></span><br><span class="line">        setCameraDisplayOrientation();</span><br><span class="line">        <span class="comment">//开始预览</span></span><br><span class="line">        mCamera.startPreview();</span><br><span class="line"></span><br><span class="line">        startFaceDetect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置预览的时候，可以设置<code>setPreviewCallback</code>监听预览数据的回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="设置相机参数"><a href="#设置相机参数" class="headerlink" title="设置相机参数"></a>设置相机参数</h3><p>设置相机参数后，需要重新启动预览，这边在初始化的时候，已经设置好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initParameters</span><span class="params">(<span class="keyword">final</span> Camera camera)</span> </span>&#123;</span><br><span class="line">    mParameters = camera.getParameters();</span><br><span class="line">    mParameters.setPreviewFormat(ImageFormat.NV21); <span class="comment">//default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSupportFocus(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123;</span><br><span class="line">        mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSupportFocus(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</span><br><span class="line">        mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置预览图片大小</span></span><br><span class="line">    setPreviewSize();</span><br><span class="line">    <span class="comment">//设置图片大小</span></span><br><span class="line">    setPictureSize();</span><br><span class="line"></span><br><span class="line">    camera.setParameters(mParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Camera.Parameters可以设置的参数非常多，这里就介绍几个比较常用的<br><img src="https://s2.ax1x.com/2020/01/15/lXPg5q.png" alt="Camera.Parameters"></p><h4 id="1-setFocusMode"><a href="#1-setFocusMode" class="headerlink" title="1.setFocusMode"></a>1.setFocusMode</h4><p>设置对焦模式    </p><ul><li>FOCUS_MODE_AUTO：自动对焦</li><li>FOCUS_MODE_INFINITY：无穷远</li><li>FOCUS_MODE_MACRO：微距</li><li>FOCUS_MODE_FIXED：固定焦距</li><li>FOCUS_MODE_EDOF：景深扩展</li><li>FOCUS_MODE_CONTINUOUS_PICTURE：持续对焦(针对照片)</li><li>FOCUS_MODE_CONTINUOUS_VIDEO：(针对视频)</li></ul><h4 id="2-setPreviewSize"><a href="#2-setPreviewSize" class="headerlink" title="2.setPreviewSize"></a>2.setPreviewSize</h4><p>设置预览图片大小</p><h4 id="3-setPreviewFormat"><a href="#3-setPreviewFormat" class="headerlink" title="3.setPreviewFormat"></a>3.setPreviewFormat</h4><p>支持的格式： </p><ul><li>ImageFormat.NV16</li><li>ImageFormat.NV21</li><li>ImageFormat.YUY2</li><li>ImageFormat.YV12</li><li>ImgaeFormat.RGB_565</li><li>ImageFormat.JPEG<br>如果不设置，默认返回NV21的数据</li></ul><h4 id="4-setPictureSize"><a href="#4-setPictureSize" class="headerlink" title="4.setPictureSize"></a>4.setPictureSize</h4><p>设置保存图片的大小</p><h4 id="5-setPictureFormat"><a href="#5-setPictureFormat" class="headerlink" title="5.setPictureFormat"></a>5.setPictureFormat</h4><p>设置保存图片的格式，格式和<code>setPreviewFormat</code>一样</p><h4 id="6-setDisplayOrientation"><a href="#6-setDisplayOrientation" class="headerlink" title="6.setDisplayOrientation"></a>6.setDisplayOrientation</h4><p>设置相机预览画面旋转的角度，degress取值0，90，180，270</p><h4 id="7-setPreviewDisplay"><a href="#7-setPreviewDisplay" class="headerlink" title="7.setPreviewDisplay"></a>7.setPreviewDisplay</h4><p>设置实时预览SurfaceHolder</p><h4 id="8-setPreviewCallback"><a href="#8-setPreviewCallback" class="headerlink" title="8.setPreviewCallback"></a>8.setPreviewCallback</h4><p>监听相机预览数据回调</p><h4 id="9-setParameters"><a href="#9-setParameters" class="headerlink" title="9.setParameters"></a>9.setParameters</h4><p>设置相机的Parameters<br>其他一些设置，大家可以查看Android文档进行相应的设置</p><h3 id="设置方向"><a href="#设置方向" class="headerlink" title="设置方向"></a>设置方向</h3><p>设置相机的预览方向，<a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4#heading-7" target="_blank" rel="noopener">orientation比较详细的介绍</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCameraDisplayOrientation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line">    Camera.getCameraInfo(mCameraId, cameraInfo);</span><br><span class="line">    <span class="keyword">int</span> rotation = getWindowManager().getDefaultDisplay().getRotation();  <span class="comment">//自然方向</span></span><br><span class="line">    <span class="keyword">int</span> degrees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_0:</span><br><span class="line">            degrees = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">            degrees = <span class="number">90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_180:</span><br><span class="line">            degrees = <span class="number">180</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_270:</span><br><span class="line">            degrees = <span class="number">270</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">//cameraInfo.orientation 图像传感方向</span></span><br><span class="line">    <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        result = (cameraInfo.orientation + degrees) % <span class="number">360</span>;</span><br><span class="line">        result = (<span class="number">360</span> - result) % <span class="number">360</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = (cameraInfo.orientation - degrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOrientation = result;</span><br><span class="line">    <span class="comment">//相机预览方向</span></span><br><span class="line">    mCamera.setDisplayOrientation(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mCamera) &#123;</span><br><span class="line">        mCamera.takePicture(<span class="keyword">new</span> Camera.ShutterCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//base data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">                <span class="comment">//save data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>takePicture的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">(ShutterCallback shutter, PictureCallback raw,</span></span></span><br><span class="line"><span class="function"><span class="params">            PictureCallback jpeg)</span> </span>&#123;</span><br><span class="line">        takePicture(shutter, raw, <span class="keyword">null</span>, jpeg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>shutter(ShutterCallback)：快门按下后的回调</li><li>raw(PictureCallback)：raw图像数据</li><li>jpeg(PictureCallback)：jpeg图像生成以后的回调</li></ul><h3 id="释放相机资源"><a href="#释放相机资源" class="headerlink" title="释放相机资源"></a>释放相机资源</h3><p>在使用完成后，onPause或者onDestory中进行相机资源的释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mCamera) &#123;</span><br><span class="line">        mCamera.stopPreview();</span><br><span class="line">        mCamera.stopFaceDetection();</span><br><span class="line">        mCamera.setPreviewCallback(<span class="keyword">null</span>);</span><br><span class="line">        mCamera.release();</span><br><span class="line">        mCamera = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>stopPreview：停止预览</li><li>release：释放资源</li></ul><p>Camera1的开发上，还是相对比较简单的，需要定制的功能项比较少，下面一篇开始介绍Camera2的使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/f63f296a920b" target="_blank" rel="noopener">Android Camera 编程从入门到精通</a></li><li><a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4" target="_blank" rel="noopener">Android之Camera1实现相机开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了&lt;a href=&quot;https://github.com/google/cameraview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CameraView&lt;/a&gt;，提供给开发者参考和学习，现在最新的可以使用&lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/camerax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jetpack CameraX&lt;/a&gt;来开发，大大简化了开发的复杂度。本系列从Camera1-&amp;gt;Camera2-&amp;gt;CameraView-&amp;gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
      <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-基础知识篇</title>
    <link href="http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/"/>
    <id>http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/</id>
    <published>2020-01-14T19:49:33.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。<br>需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。     </p><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Android Framework提供Camera API来实现拍照与录制视频的功能，目前Android有三类API，</p><ul><li><a href="https://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">Camera</a><br>此类是用于控制设备相机的旧版 API，现已弃用，在Android5.0以下使用</li><li><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html" target="_blank" rel="noopener">Camera2</a><br>此软件包是用于控制设备相机的主要 API，Android5.0以上使用</li><li><a href="https://developer.android.com/training/camerax" target="_blank" rel="noopener">CameraX</a><br>基于Camera 2 API封装，简化了开发流程，并增加生命周期控制</li></ul><h2 id="相关开发类"><a href="#相关开发类" class="headerlink" title="相关开发类"></a>相关开发类</h2><ul><li><a href="https://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">android.hardware.camera2</a><br>控制相机的核心API，使用它可以实现拍照和录制视频的功能。</li><li><a href="https://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="noopener">Camera</a><br>此类是用于控制设备相机的旧版 API，现已弃用。</li><li><a href="https://developer.android.com/reference/android/view/SurfaceView.html" target="_blank" rel="noopener">SurfaceView</a><br>此类用于向用户呈现实时相机预览。</li><li><a href="https://developer.android.com/reference/android/view/TextureView" target="_blank" rel="noopener">TextureView</a><br>也是用于实时相机预览，Android4.0之后引入</li><li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html" target="_blank" rel="noopener">MediaRecorder</a><br>用于录制视频</li><li><a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a><br>MediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE 的 Intent 操作类型可用于捕获图像或视频，而无需直接使用 Camera 对象。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><strong>ISO(感光度)</strong><br>CMOS（或胶卷）对光线的敏感程度，用ISO100的胶卷，相机2秒可以正确曝光的话，同样光线条件下用ISO200的胶卷只需要1秒即可，用ISO400则只要0.5秒。<br>常见的标准：ISO100，ISO200，ISO400</li><li><strong>曝光时间</strong><br>曝光时间是为了将光投射到相机感光片上，相机快门所要打开至关闭的时间</li><li><strong>光圈</strong><br>用来控制光线透过镜头，进入相机内感光面光量的装置</li><li><strong>焦距</strong><br>指的是平行的光线穿过镜片后，所汇集的焦点至镜片间之距离。<br>数值越小，代表可以拍摄的角度越广，数值越大，代表可以拍摄的角度越小 </li><li><strong>景深</strong><br>拍摄时，当镜头聚集于某个被摄体时，这个被摄体就能在相机上结成清晰影像。使被摄体产生较为清晰影像的纵深的范围叫景深 </li><li><strong>测光</strong><br>测光模式：中央平均测光(average metering)、中央局部测光、点测光(spot metering)、多点测光、评价测光</li><li><strong>自动曝光(Auto Exposure)</strong><br>相机根据光线条件自动来调整曝光时间等来确定曝光量</li><li><strong>对焦</strong><br>对焦模式：自动对焦 AE(Auto Focus)、手动对焦 MF(Manual Focus)<br>自动对焦分为对比度对焦(contrast)、相位对焦(PDAF: Phase Detection Auto Focus)和混合对焦(hybrid)</li><li><strong>闪光灯(Flashlight)</strong><br>通过闪光灯打闪照亮物体来达到拍出清晰图片的目的</li><li><strong>ScreenFlash</strong><br>通过屏幕打闪，照亮周围物体，拍出高清图片</li><li><strong>高动态范围图像(HDR)</strong><br>HDR全称是High-Dynamic Range，即高动态范围图像技术。在拍照过程中开启HDR，可以让原先的暗场景变得更明亮更通透。</li><li><strong>零延时拍照(ZSD)</strong><br>为了减少拍照延时,让拍照&amp;回显瞬间完成的一种技术</li><li><strong>连拍(ContinuousShot)</strong><br>通过节约数据传输时间来捕捉摄影时机</li><li><strong>预览大小(PreviewSize)</strong><br>相机预览图片的大小 </li><li><strong>拍照大小(PictureSize)</strong><br>拍照生成图片的大小 </li><li><strong>自动白平衡(Auto white balance)</strong><br>AWB(Auto white balance)，自动白平衡是相机的默认设置，相机中有一结构复杂的矩形图，它可决定画面中的白平衡基准点，以此来达到白平衡调校</li><li><strong>对比度</strong><br>图像最亮和最暗之间的区域之间的比率，比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富</li><li><strong>饱和度</strong><br>指色彩的鲜艳程度</li><li><strong>锐度</strong><br>是反映图像平面清晰度和图像边缘锐利程度的一个指标</li></ol><h2 id="相机功能"><a href="#相机功能" class="headerlink" title="相机功能"></a>相机功能</h2><p>Android 支持多种相机功能，您可使用相机应用控制这些功能，如图片格式、闪光模式、对焦设置等等。<br>通过<code>Camera.Parameters</code>可以设置大部分的功能，下面介绍几个重要功能：</p><ul><li>区域测光和对焦</li><li>人脸检测</li><li>延时视频</li></ul><h3 id="区域测光和对焦"><a href="#区域测光和对焦" class="headerlink" title="区域测光和对焦"></a>区域测光和对焦</h3><p>从 Android 4.0（API 级别 14）开始，通过<code>Camera.Parameters</code>来确定对焦或亮度设置的区域，然后进行拍照或者录像</p><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><p>这个和真正的人脸识别是不一样的 ，这里仅仅是检测人脸。<br>通过照片分析，检测照片中是否包含人脸，使用人脸识别技术来识别人脸并计算照片设置</p><h3 id="延时视频"><a href="#延时视频" class="headerlink" title="延时视频"></a>延时视频</h3><p>延时视频功能允许用户将间隔几秒钟或几分钟拍摄的图片串联起来，创建视频剪辑。使用<code>MediaRecorder</code>录制时间流逝片段的图像。</p><p>其他重要功能API：<br><img src="https://s2.ax1x.com/2020/01/14/lqLgsK.png" alt="功能API"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/training/camerax" target="_blank" rel="noopener">CameraX</a></li><li><a href="https://developer.android.com/training/camera" target="_blank" rel="noopener">Camera</a></li><li><a href="https://medium.com/google-developers/detecting-camera-features-with-camera2-61675bb7d1bf#.2x3icoqnc" target="_blank" rel="noopener">Detecting camera features with Camera2</a></li><li><a href="http://hukai.me/android-dev-camera-basics/" target="_blank" rel="noopener">Android相机开发 - 1)基础概览篇</a></li><li><a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4" target="_blank" rel="noopener">Android之Camera1实现相机开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。&lt;br&gt;需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。     &lt;/p&gt;
    
    </summary>
    
      <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
      <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
      <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
      <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-系列文章</title>
    <link href="http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/"/>
    <id>http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/</id>
    <published>2020-01-13T10:44:49.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较忙，文章也很久没有更新了。<br>最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到了，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ul><li><a href="/2020/01/13/AndroidCamera-Basic/">Camera基础知识</a></li><li>Camera1使用</li><li>Camera2使用</li><li>Google CameraView使用</li><li>AndroidX使用</li><li>应用场景分析-扫码</li><li>应用场景分析-人脸识别</li><li>Google CameraView源码分析</li><li>AndroidX源码分析</li><li>Camera系统源码分析</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://source.android.com/devices/camera" target="_blank" rel="noopener">Android Camera</a></li><li><a href="https://developer.android.com/jetpack/androidx" target="_blank" rel="noopener">AndroidX</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b" target="_blank" rel="noopener">Android Camera 编程从入门到精通</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比较忙，文章也很久没有更新了。&lt;br&gt;最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到了，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
      <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
      <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
      <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK-深入理解JNI</title>
    <link href="http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/"/>
    <id>http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/</id>
    <published>2019-08-21T11:21:43.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>Java调用C/C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。</p><a id="more"></a><h1 id="JNI-概述"><a href="#JNI-概述" class="headerlink" title="JNI 概述"></a>JNI 概述</h1><p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native语言的一种特性，通过JNI可以使JAVA和 C/C++进行交互。<br>Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。<br>在Java语言出现前，就有很多程序和库都是由Native语言写的，如果想重复利用这些库，就可以所使用JNI来实现。在Android平台上，JNI就是一座将Java世界和Native世界联通的一座桥梁。<br><img src="https://s2.ax1x.com/2019/08/30/mOgNGD.png" alt="jni.png"><br>通过JNI，Java世界和Native世界的代码就可以相互访问了。</p><h1 id="JNI实例：Camera"><a href="#JNI实例：Camera" class="headerlink" title="JNI实例：Camera"></a>JNI实例：Camera</h1><p>最新有在看系统的Camera相关，所以从系统Camera角度来分析下JNI的应用，下面讲的实例基于Camera2</p><blockquote><p>Android5.0(21)之后android.hardware.Camera就被废弃了，取而代之的是全新的android.hardware.Camera2</p></blockquote><p>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/hardware/camera2/impl/CameraMetadataNative.java</span><br><span class="line">frameworks/base/core/jni/android_hardware_camera2_CameraMetadata.cpp</span><br></pre></td></tr></table></figure><p>Camera2 Java层对应的是CameraMetadataNative.java，Native层对应的是android_hardware_camera2_CameraMetadata.cpp</p><h2 id="Java层CameraMetadataNative"><a href="#Java层CameraMetadataNative" class="headerlink" title="Java层CameraMetadataNative"></a>Java层CameraMetadataNative</h2><p>相关代码在CameraMetadataNative.java<br>Camera2使用CameraManager(摄像头管理器)进行控制，CameraManager具体的操作会通过CameraMetadataNative来执行。<br>CameraMetadataNative的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraMetadataNative</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span></span><br><span class="line"><span class="class">   <span class="title">static</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * We use a class initializer to allow the native code to cache some field offsets</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      nativeClassInit();</span><br><span class="line">      registerAllMarshalers();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeClassInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法初始化调用了Native层的方法<code>nativeClassInit</code>，这个方法对应的Native层具体实现，是在android_hardware_camera2_CameraMetadata.cpp</p><h2 id="Native层CameraMetadata"><a href="#Native层CameraMetadata" class="headerlink" title="Native层CameraMetadata"></a>Native层CameraMetadata</h2><p>Native层相关代码在android_hardware_camera2_CameraMetadata.cpp<br>Native方法初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gCameraMetadataMethods[] = &#123;</span><br><span class="line"><span class="comment">// static methods</span></span><br><span class="line">  &#123; <span class="string">"nativeClassInit"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_classInit &#125;,   <span class="comment">//和Java层nativeClassInit()对应</span></span><br><span class="line">  &#123; <span class="string">"nativeGetAllVendorKeys"</span>,</span><br><span class="line">    <span class="string">"(Ljava/lang/Class;)Ljava/util/ArrayList;"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_getAllVendorKeys&#125;,</span><br><span class="line">  &#123; <span class="string">"nativeGetTagFromKey"</span>,</span><br><span class="line">    <span class="string">"(Ljava/lang/String;)I"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_getTagFromKey &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeGetTypeFromTag"</span>,</span><br><span class="line">    <span class="string">"(I)I"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_getTypeFromTag &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeSetupGlobalVendorTagDescriptor"</span>,</span><br><span class="line">    <span class="string">"()I"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)CameraMetadata_setupGlobalVendorTagDescriptor &#125;,</span><br><span class="line"><span class="comment">// instance methods</span></span><br><span class="line">  &#123; <span class="string">"nativeAllocate"</span>,</span><br><span class="line">    <span class="string">"()J"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)CameraMetadata_allocate &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeAllocateCopy"</span>,</span><br><span class="line">    <span class="string">"(L"</span> CAMERA_METADATA_CLASS_NAME <span class="string">";)J"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_allocateCopy &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeIsEmpty"</span>,</span><br><span class="line">    <span class="string">"()Z"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)CameraMetadata_isEmpty &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeGetEntryCount"</span>,</span><br><span class="line">    <span class="string">"()I"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)CameraMetadata_getEntryCount &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeClose"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)CameraMetadata_close &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeSwap"</span>,</span><br><span class="line">    <span class="string">"(L"</span> CAMERA_METADATA_CLASS_NAME <span class="string">";)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_swap &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeReadValues"</span>,</span><br><span class="line">    <span class="string">"(I)[B"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_readValues &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeWriteValues"</span>,</span><br><span class="line">    <span class="string">"(I[B)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_writeValues &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeDump"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_dump &#125;,</span><br><span class="line"><span class="comment">// Parcelable interface</span></span><br><span class="line">  &#123; <span class="string">"nativeReadFromParcel"</span>,</span><br><span class="line">    <span class="string">"(Landroid/os/Parcel;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_readFromParcel &#125;,</span><br><span class="line">  &#123; <span class="string">"nativeWriteToParcel"</span>,</span><br><span class="line">    <span class="string">"(Landroid/os/Parcel;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_writeToParcel &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gCameraMetadataMethods什么时候会被加载？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_hardware_camera2_CameraMetadata</span><span class="params">(JNIEnv *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// Register native functions</span></span><br><span class="line">   <span class="keyword">return</span> RegisterMethodsOrDie(env,</span><br><span class="line">         CAMERA_METADATA_CLASS_NAME,</span><br><span class="line">         gCameraMetadataMethods,</span><br><span class="line">         NELEM(gCameraMetadataMethods));</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RegisterMethodsOrDie</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(res &lt; <span class="number">0</span>, <span class="string">"Unable to register native methods."</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register_android_hardware_camera2_CameraMetadata</code>何时会被调用到，这个就需要了解下JNI的查找方式。</p><h2 id="JNI查找方式"><a href="#JNI查找方式" class="headerlink" title="JNI查找方式"></a>JNI查找方式</h2><blockquote><p>Android系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。  </p></blockquote><p>刚才CameraMetadata中<code>register_android_hardware_camera2_CameraMetadata</code>方法，在AndroidRuntime.cpp的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_android_hardware_camera2_CameraMetadata</span><span class="params">(JNIEnv *env)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在gRegJNI中的静态声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    REG_JNI(register_android_hardware_camera2_CameraMetadata),</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gRegJNI方法在startReg中被调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"RegisterAndroidNatives"</span>);</span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</span><br><span class="line">  </span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createJavaThread("fubar", quickTest, (void*) "hello");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register_jni_procs(gRegJNI, NELEM(gRegJNI), env)会循环调用gRegJNI数组成员所对应的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            ALOGD(<span class="string">"----------!!! %s failed to load\n"</span>, <span class="built_in">array</span>[i].mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样android_hardware_camera2_CameraMetadata.cpp中的<code>int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)</code>就会被调用到。<br>除了这种Android系统启动时，就注册JNI所对应的方法。还有一种就是程序自定义的JNI方法，以 MediePlay 为例：<br>相关代码路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/media/java/android/media/MediaPlayer.java</span><br><span class="line">frameworks/base/media/jni/android_media_MediaPlayer.cpp</span><br></pre></td></tr></table></figure><p>MediaPlayer声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span> <span class="keyword">extends</span> <span class="title">PlayerBase</span></span></span><br><span class="line"><span class="class">                         <span class="keyword">implements</span> <span class="title">SubtitleController</span>.<span class="title">Listener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">      native_init();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块中使用System.loadLibrary加载动态库，media_jni在Android平台对应的是libmedia_jni.so库。<br>在jni目录<code>/frameworks/base/media/jni/Android.mk</code>中有相应的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES:= \</span><br><span class="line">android_media_MediaPlayer.cpp \</span><br><span class="line">...</span><br><span class="line">LOCAL_MODULE:= libmedia_jni</span><br></pre></td></tr></table></figure><p>在<code>android_media_MediaPlayer.cpp</code>找到对应的Native(natvie_init)方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"android/media/MediaPlayer"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI注册的方法就是上面描述的两种方法：</p><ul><li>在Android系统启动时注册，在AndroidRuntime.cpp中的gRegJNI方法中声明</li><li>使用System.loadLibrary()方式注册</li></ul><h1 id="JNI基础"><a href="#JNI基础" class="headerlink" title="JNI基础"></a>JNI基础</h1><p>上面一节主要描述了系统中Java层和Native层交互和实现，并没有对JNI的基础理论，流程进行分析</p><h2 id="JNI命名规则"><a href="#JNI命名规则" class="headerlink" title="JNI命名规则"></a>JNI命名规则</h2><p>JNI方法名规范 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值 + Java前缀 + 全路径类名 + 方法名 + 参数① JNIEnv + 参数② jobject + 其它参数</span><br></pre></td></tr></table></figure><p>简单的一个例子，返回一个字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI(JNIEnv *env, jclass jclass1) &#123;</span><br><span class="line">    LOGD(<span class="string">"##### from c"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"Hello JNI"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值：jstring</li><li>全路径类名：com_yeungeek_jnisample_NativeHelper</li><li>方法名：stringFromJNI</li></ul><h2 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h2><ul><li>在Java中先声明一个native方法</li><li>编译Java源文件javac得到.class文件</li><li>通过javah -jni命令导出JNI的.h头文件</li><li>使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li><li>将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li><li>通过Java命令执行Java程序，最终实现Java调用本地代码。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table><thead><tr><th align="left">Signature</th><th align="left">Java</th><th align="left">Native</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">byte</td><td align="left">jbyte</td></tr><tr><td align="left">C</td><td align="left">char</td><td align="left">jchar</td></tr><tr><td align="left">D</td><td align="left">double</td><td align="left">jdouble</td></tr><tr><td align="left">F</td><td align="left">float</td><td align="left">jfloat</td></tr><tr><td align="left">I</td><td align="left">int</td><td align="left">jint</td></tr><tr><td align="left">S</td><td align="left">short</td><td align="left">jshort</td></tr><tr><td align="left">J</td><td align="left">long</td><td align="left">jlong</td></tr><tr><td align="left">Z</td><td align="left">boolean</td><td align="left">jboolean</td></tr><tr><td align="left">V</td><td align="left">void</td><td align="left">jvoid</td></tr></tbody></table><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><table><thead><tr><th align="left">Signature</th><th align="left">Java</th><th align="left">Native</th></tr></thead><tbody><tr><td align="left">L+classname +;</td><td align="left">Object</td><td align="left">jobject</td></tr><tr><td align="left">Ljava/lang/String;</td><td align="left">String</td><td align="left">jstring</td></tr><tr><td align="left">[L+classname +;</td><td align="left">Object[]</td><td align="left">jobjectArray</td></tr><tr><td align="left">Ljava.lang.Class;</td><td align="left">Class</td><td align="left">jclass</td></tr><tr><td align="left">Ljava.lang.Throwable;</td><td align="left">Throwable</td><td align="left">jthrowable</td></tr><tr><td align="left">[B</td><td align="left">byte[]</td><td align="left">jbyteArray</td></tr><tr><td align="left">[C</td><td align="left">char[]</td><td align="left">jcharArray</td></tr><tr><td align="left">[D</td><td align="left">double[]</td><td align="left">jdoubleArray</td></tr><tr><td align="left">[F</td><td align="left">float[]</td><td align="left">jfloatArray</td></tr><tr><td align="left">[I</td><td align="left">int[]</td><td align="left">jintArray</td></tr><tr><td align="left">[S</td><td align="left">short[]</td><td align="left">jshortArray</td></tr><tr><td align="left">[J</td><td align="left">long[]</td><td align="left">jlongArray</td></tr><tr><td align="left">[Z</td><td align="left">boolean[]</td><td align="left">jbooleanArray</td></tr></tbody></table><h2 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h2><p>JNI的方法签名的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数签名格式...)返回值签名格式</span><br></pre></td></tr></table></figure><p>demo的native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> java.lang.<span class="function">String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以通过javap命令生成方法签名``：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()Ljava/lang/String;</span><br></pre></td></tr></table></figure><h1 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h1><p>Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。<br>JNI 定义了两个关键数据结构，即“JavaVM”和“JNIEnv”，两者本质上都是指向函数表的二级指针。</p><h2 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h2><p>JavaVM是Java虚拟机在JNI层的代表，JavaVM 提供了“调用接口”函数，您可以利用此类函数创建和销毁 JavaVM。理论上，每个进程可以包含多个JavaVM，但AnAndroid只允许每个进程包含一个JavaVM。</p><h2 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h2><p>JNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。JNIEnv 提供了大多数 JNI 函数。您的原生函数均会接收 JNIEnv 作为第一个参数。<br>JNIEnv作用：</p><ul><li>调用Java函数</li><li>操作Java代码</li></ul><p>JNIEnv定义(jni.h)：<br><code>libnativehelper/include/nativehelper/jni.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span>* <span class="title">JNIEnv</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>定义中可以看到JavaVM，Android中一个进程只会有一个JavaVM，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构<br><img src="https://s2.ax1x.com/2019/09/01/n9wYL9.png" alt="javavm.png"></p><h2 id="注册JNI函数"><a href="#注册JNI函数" class="headerlink" title="注册JNI函数"></a>注册JNI函数</h2><p>Java世界和Native世界的方法是如何关联的，就是通过JNI函数注册来实现。JNI函数注册有两种方式：</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>这种方法就是通过函数名来找对应的JNI函数，可以通过<code>javah</code>命令行来生成JNI头文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah com.yeungeek.jnisample.NativeHelper</span><br></pre></td></tr></table></figure><p>生成对应的<code>com_yeungeek_jnisample_NativeHelper.h</code>文件，生成对应的JNI函数，然后在实现这个函数就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_yeungeek_jnisample_NativeHelper</span></span><br><span class="line"><span class="comment"> * Method:    stringFromJNI</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI</span><br><span class="line">  (JNIEnv *, jclass);</span><br></pre></td></tr></table></figure><p>静态注册方法中，Native是如何找到对应的JNI函数，在<a href="#JNI查找方式">JNI查找方式</a>中介绍系统的流程，并没有详细说明静态注册的查找。这里简单说明下这个过程(以上面的声明为例子s)：<br>当Java调用native stringFromJNI函数时，会从对应JNI库中查找<code>Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI</code>函数，如果没有找到，就会报错。<br>静态注册方法，就是根据函数名来关联Java函数和JNI函数，JNI函数需要遵循特定的格式，这其中就有一些缺点：</p><ul><li>声明了native方法的Java类，需要通过<code>javah</code>来生成头文件</li><li>JNI函数名称非常长</li><li>第一次调用native函数，需要通过函数名来搜索关联对应的JNI函数，效率比较低</li></ul><p>如何解决这些问题，让native函数，提前知道JNI函数，就可以解决这个问题，这个过程就是动态注册。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册在前面的Camera例子中，已经有涉及到，JNI函数<code>classInit</code>的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gCameraMetadataMethods[] = &#123;</span><br><span class="line"><span class="comment">// static methods</span></span><br><span class="line">  &#123; <span class="string">"nativeClassInit"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)CameraMetadata_classInit &#125;,   <span class="comment">//和Java层nativeClassInit()对应</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativeMethod，它在jni.h中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;  <span class="comment">//Java层native函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature; <span class="comment">//Java函数签名，记录参数类型和个数，以及返回值类型</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr; <span class="comment">//Native层对应的函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure><p>在<a href="#JNI查找方式">JNI查找方式</a>说到，JNI注册的两种时间，第一种已经介绍过了，我们自定义的native函数，基本都是会使用<code>System.loadLibrary(“xxx”)</code>，来进行JNI函数的关联。</p><h4 id="loadLibrary-Android7-0"><a href="#loadLibrary-Android7-0" class="headerlink" title="loadLibrary(Android7.0)"></a>loadLibrary(Android7.0)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">   Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到Runtime(libcore/ojluni/src/main/java/java/lang/Runtime.java)的loadLibrary0方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, String libname)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   String libraryName = libname;</span><br><span class="line">   <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String filename = loader.findLibrary(libraryName);</span><br><span class="line">      <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">            <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">            <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">            <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                          System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//doLoad</span></span><br><span class="line">      String error = doLoad(filename, loader);</span><br><span class="line">      <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//loader 为 null</span></span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">for</span> (String directory : getLibPaths()) &#123;</span><br><span class="line">      String candidate = directory + filename;</span><br><span class="line">      candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doLoad"><a href="#doLoad" class="headerlink" title="doLoad"></a>doLoad</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//调用 native 方法</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nativeLoad"><a href="#nativeLoad" class="headerlink" title="nativeLoad"></a>nativeLoad</h4><p>进入到虚拟机代码<code>/libcore/ojluni/src/main/native/Runtime.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jstring javaLibrarySearchPath)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>JVM_NativeLoad</code>，JVM_NativeLoad方法申明在jvm.h中，实现在<code>OpenjdkJvm.cc(/art/runtime/openjdkjvm/OpenjdkJvm.cc)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jstring <span class="title">JVM_NativeLoad</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaFilename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaLibrarySearchPath)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         javaLibrarySearchPath,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span></span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  <span class="keyword">return</span> env-&gt;NewStringUTF(error_msg.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LoadNativeLibrary"><a href="#LoadNativeLibrary" class="headerlink" title="LoadNativeLibrary"></a>LoadNativeLibrary</h4><p>调用JavaVMExt的LoadNativeLibrary方法，方法在(art/runtime/java_vm_ext.cc)中，这个方法代码非常多，选取主要的部分进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JavaVMExt::LoadNativeLibrary(JNIEnv* env,</span><br><span class="line">                                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path,</span><br><span class="line">                                  jobject class_loader,</span><br><span class="line">                                  jstring library_path,</span><br><span class="line">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg) &#123;</span><br><span class="line">         ......</span><br><span class="line">         <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">//加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功，</span></span><br><span class="line">         <span class="comment">//如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数，</span></span><br><span class="line">         <span class="comment">//所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用java中申明的native方法时会抛出异常</span></span><br><span class="line">         <span class="keyword">void</span>* sym = library-&gt;FindSymbol(<span class="string">"JNI_OnLoad"</span>, <span class="literal">nullptr</span>);</span><br><span class="line">         <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            VLOG(jni) &lt;&lt; <span class="string">"[No JNI_OnLoad found in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">            was_successful = <span class="literal">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Call JNI_OnLoad.  We have to override the current class</span></span><br><span class="line">            <span class="comment">// loader, which will always be "null" since the stuff at the</span></span><br><span class="line">            <span class="comment">// top of the stack is around Runtime.loadLibrary().  (See</span></span><br><span class="line">            <span class="comment">// the comments in the JNI FindClass function.)</span></span><br><span class="line">            ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">            self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">            VLOG(jni) &lt;&lt; <span class="string">"[Calling JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">            <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*JNI_OnLoadFn)</span><span class="params">(JavaVM*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">            JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">            <span class="comment">//调用JNI_OnLoad方法</span></span><br><span class="line">            <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runtime_-&gt;GetTargetSdkVersion() != <span class="number">0</span> &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">               <span class="comment">// Make sure that sigchain owns SIGSEGV.</span></span><br><span class="line">               EnsureFrontOfChain(SIGSEGV);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line">         &#125;</span><br><span class="line">         ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的主要逻辑：</p><ul><li>加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功</li><li>如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数</li><li>所以如果采用动态注册就必须要实现<code>JNI_OnLoad</code>方法，否则调用Java中的native方法时会抛出异常</li></ul><h2 id="jclass、jmethodID和jfieldID"><a href="#jclass、jmethodID和jfieldID" class="headerlink" title="jclass、jmethodID和jfieldID"></a>jclass、jmethodID和jfieldID</h2><p>如果要通过原生代码访问对象的字段，需要执行以下操作：</p><ol><li>使用 FindClass 获取类的类对象引用</li><li>使用 GetFieldID 获取字段的字段 ID</li><li>使用适当内容获取字段的内容，例如 GetIntField</li></ol><p>具体的使用，放在第二篇文章中讲解</p><h2 id="JNI的引用"><a href="#JNI的引用" class="headerlink" title="JNI的引用"></a>JNI的引用</h2><p>JNI规范中定义了三种引用：</p><ul><li>局部引用（Local Reference）</li><li>全局引用（Global Reference）</li><li>弱全局引用（Weak Global Reference）</li></ul><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>也叫本地引用，在 JNI层函数使用的非全局引用对象都是Local Reference，最大的特点就是，JNI 函数返回后，这些声明的引用可能就会被垃圾回收</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>这种声明的对象，不会主动释放资源，不会被垃圾回收</p><h3 id="弱全局引用"><a href="#弱全局引用" class="headerlink" title="弱全局引用"></a>弱全局引用</h3><p>一种特殊的全局引用，在运行过程中可能被回收，使用之前需要判断下是否为空</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/59827fb86fb9a03c341907e6" target="_blank" rel="noopener">Android：清晰讲解JNI 与 NDK（含实例教学）</a></li><li><a href="https://www.jianshu.com/nb/22528035" target="_blank" rel="noopener">Android JNI学习</a></li><li><a href="http://gityuan.com/2016/05/28/android-jni/" target="_blank" rel="noopener">Android JNI原理分析</a></li><li><a href="http://liuwangshu.cn/framework/jni/1-mediarecorder_register.html" target="_blank" rel="noopener">Android深入理解JNI（一）JNI原理与静态、动态注册</a></li><li><a href="https://developer.android.com/training/articles/perf-jni" target="_blank" rel="noopener">JNI Tips</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java调用C/C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。&lt;/p&gt;
    
    </summary>
    
      <category term="Android框架层" scheme="http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
    
      <category term="JNI" scheme="http://yeungeek.github.io/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yeungeek.github.io/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Retrofit源码角度分析Http</title>
    <link href="http://yeungeek.github.io/2019/07/25/Network-Retrofit/"/>
    <id>http://yeungeek.github.io/2019/07/25/Network-Retrofit/</id>
    <published>2019-07-25T19:31:38.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。<br>Retofit是一个RESTful的HTTP网络请求框架，有以下特点：</p><ul><li>基于OKHttp</li><li>通过注解配置网络请求参数</li><li>支持同步、异步请求</li><li>支持多种序列化、反序列化格式</li><li>解耦彻底、模块高度封装，使用很多设计模式来实现<a id="more"></a></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面讲解的是官网的例子</p><h2 id="创建网络请求接口"><a href="#创建网络请求接口" class="headerlink" title="创建网络请求接口"></a>创建网络请求接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Retrofit实例-使用建造者模式"><a href="#创建Retrofit实例-使用建造者模式" class="headerlink" title="创建Retrofit实例(使用建造者模式)"></a>创建Retrofit实例(使用建造者模式)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">    .baseUrl(&quot;https://api.github.com/&quot;)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="创建网络接口实例"><a href="#创建网络接口实例" class="headerlink" title="创建网络接口实例"></a>创建网络接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line"></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"yeungeek"</span>);</span><br></pre></td></tr></table></figure><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>默认返回的是OKHttpCall，实际真正发送请求的就是OKHttp</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;List&lt;Repo&gt;&gt; list = repos.execute()</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>具体的请求流程可以分为7大步骤<br><img src="https://s2.ax1x.com/2019/08/13/mPNBQK.png" alt="retrofit"></p><ol><li>解析网络请求接口的注解，配置网络请求参数</li><li>通过动态代理生成网络请求对象</li><li>通过CallAdapter，将网络请求对象进行平台适配(Android,Java8)</li><li>通过网络请求执行器(Call)，发送网络请求</li><li>通过Converter进行数据解析</li><li>通过回调执行器，进行线程切换</li><li>在主线程处理返回结果</li></ol><p>Refrofit最大特点是使用了大量的设计模式，来进行解耦，下图是完整的流程图(来自<a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Stay 在 Retrofit分析-漂亮的解耦套路</a>)：<br><img src="https://s2.ax1x.com/2019/08/17/muu48s.png" alt="retrofit 流程图"><br>接下来通过源码分析，详细讲解上面的流程</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Retrofit初始化"><a href="#Retrofit初始化" class="headerlink" title="Retrofit初始化"></a>Retrofit初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit  <span class="comment">//1. Retrofit声明</span></span><br><span class="line">    .Builder()                    <span class="comment">//2. Builder</span></span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)   <span class="comment">//3. baseUrl</span></span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())  <span class="comment">//4. Converter Factory</span></span><br><span class="line">    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())  <span class="comment">//5. CallAdapter Factory</span></span><br><span class="line">    .build();                    <span class="comment">//6. 生成实例</span></span><br></pre></td></tr></table></figure><h3 id="Retrofit声明"><a href="#Retrofit声明" class="headerlink" title="Retrofit声明"></a>Retrofit声明</h3><p>在使用Retrofit时，首先通过建造者模式构建Retrofit。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>serviceMethodCache：网络请求配置对象缓存，通过解析网络请求接口后得到请求对象</li><li>callFactory：网络请求器工厂(Call)，默认实现是OKHttp</li><li>baseUrl：网络请求Url地址</li><li>converterFactories：数据转换器工厂集合</li><li>callAdapterFactories：请求适配器工厂集合</li><li>callbackExecutor：回调方法执行器</li><li>validateEagerly：是否提前验证请求方法</li></ul><p>剩下的步骤都是来初始化上面的参数</p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder中的参数和 Retrfit 是意义一一对应的，默认构造函数进行平台的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射来判断选择Android还是Java8，以前版本还有对IOS平台的支持，最新版本已经去掉了。<br>我们看下Android平台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//默认回调执行器，会切换到主线程</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">      <span class="comment">//默认的 CallAdapter</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</span><br><span class="line">   checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">   HttpUrl httpUrl = HttpUrl.parse(baseUrl);</span><br><span class="line">   <span class="keyword">if</span> (httpUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal URL: "</span> + baseUrl);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> baseUrl(httpUrl);</span><br><span class="line"> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class="line">  checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">  List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">  <span class="comment">//检查合法性</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把String url 转换成HttpUrl，会对baseUrl进行合法性校验(URL参数是不是以”/“结尾)</p><h3 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> </span>&#123;</span><br><span class="line">   converterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>把factory加到数据转换器集合中，看下GsonFactory.create()具体的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GsonConverterFactory(gson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">GsonConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.gson = gson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">    Retrofit retrofit) &#123;</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GsonConverterFactory使用Gson 为初始化参数，实现<code>responseBodyConverter</code>和<code>requestBodyConverter</code>接口，进行真正的数据转换处理。</p><h3 id="CallAdapterFactory"><a href="#CallAdapterFactory" class="headerlink" title="CallAdapterFactory"></a>CallAdapterFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">  callAdapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把factory加到请求适配器工厂集合中，Android 平台默认实现是ExecutorCallAdapterFactory，后面再进行详细讲解。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>最后一步build生成Retrofit对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">  callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">  converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">      unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callFactory配置，默认OkHttpClient</li><li>callbackExecutor配置，Android 平台默认使用<code>MainThreadExecutor</code></li><li>callAdapterFactories配置，先加入自定义的callAdapter，然后再加入defaultCallAdapterFactory</li><li>converterFactories配置，先加入内建转换器(BuiltInConverters)，然后加入自定义的数据转换器</li><li>生成Retrofit对象</li></ul><h2 id="创建网络接口实例-1"><a href="#创建网络接口实例-1" class="headerlink" title="创建网络接口实例"></a>创建网络接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建接口实例</span></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line"><span class="comment">//生成请求对象</span></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"yeungeek"</span>);</span><br></pre></td></tr></table></figure><p>Retrofit通过外观模式和动态代理生成网络接口实例，网络接口的请求参数从接口声明获取</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create方法中最重要的是使用了动态代理，调用接口的方法都会到Proxy的invoke方法中，在invoke方法中最重要的就是下面三行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><h3 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h3><p>该方法读取网络请求接口里的方法，根据配置生成ServiceMethod对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadServiceMethod会先从cache中获取对象，如果获取不到，则通过建造者模式生成ServiceMethod对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br></pre></td></tr></table></figure><h4 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Upper and lower characters, digits, underscores, and hyphens, starting with a character.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String PARAM = <span class="string">"[a-zA-Z][a-zA-Z0-9_-]*"</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_URL_REGEX = Pattern.compile(<span class="string">"\\&#123;("</span> + PARAM + <span class="string">")\\&#125;"</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;R, T&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, R&gt; responseConverter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String httpMethod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasBody;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFormEncoded;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMultipart;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line"></span><br><span class="line">  ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">    <span class="keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">    <span class="keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">    <span class="keyword">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers;</span><br><span class="line">    <span class="keyword">this</span>.contentType = builder.contentType;</span><br><span class="line">    <span class="keyword">this</span>.hasBody = builder.hasBody;</span><br><span class="line">    <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">    <span class="keyword">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">    <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callFactory：网络请求器工厂，和retrofit对象声明中的含义一样</li><li>callAdapter：网络请求适配器工厂</li><li>baseUrl：网络请求Url地址</li><li>responseConverter：Response 数据转换器</li><li>httpMethod：http 请求方法</li><li>relativeUrl：网络请求相对地址</li><li>headers：网络请求头</li><li>contentType：网络请求 body 类型</li><li>parameterHandlers：方法处理解析器</li></ul><h4 id="ServiceMethod-Builder"><a href="#ServiceMethod-Builder" class="headerlink" title="ServiceMethod.Builder"></a>ServiceMethod.Builder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">   <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line">   <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">   <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">   <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>methodAnnotations：网络请求接口方法注解</li><li>parameterTypes：网络请求接口方法里的参数注解</li><li>parameterAnnotationsArray：网络请求接口方法里的注解内容</li></ul><h4 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//1. 从 Retrofit 中获取网络请求器</span></span><br><span class="line">   callAdapter = createCallAdapter();</span><br><span class="line">   responseType = callAdapter.responseType();</span><br><span class="line">   <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">     <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">         + Utils.getRawType(responseType).getName()</span><br><span class="line">         + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 从 Refrofit 中获取数据转换器</span></span><br><span class="line">   responseConverter = createResponseConverter();</span><br><span class="line">   <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">   <span class="comment">//3. 解析网络请求接口中方法的注解</span></span><br><span class="line">     parseMethodAnnotation(annotation);</span><br><span class="line">   &#125;</span><br><span class="line">   .....</span><br><span class="line">   <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">   parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">     Type parameterType = parameterTypes[p];</span><br><span class="line">     <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">           parameterType);</span><br><span class="line">     &#125;</span><br><span class="line">     Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">     <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4. 创建ParameterHandler&lt;?&gt;，用来解析来解析参数使用到注解</span></span><br><span class="line">     parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCallAdapter：根据接口方法返回类型、接口请求的注解，获取网络请求器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取接口方法的返回类型</span></span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取接口请求的注解</span></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createResponseConverter：根据接口请求注解类型、返回类型，获取数据数据转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取接口请求的注解</span></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//从Rtrofit中获取数据转换器</span></span><br><span class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseMethodAnnotation：解析请求接口的方法注解，主要有以下标签</p><ul><li>Http请求方法</li><li>Headers</li><li>Multipart</li><li>FormUrlEncoded</li></ul><p>parseParameter：对方法的参数注解进行解析<br>包含：Url，Path，Query，QueryName，QueryMap，Header，HeaderMap，Field，FieldMap，Part，PartMap，Body</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">    <span class="keyword">int</span> p, Type parameterType, Annotation[] annotations) &#123;</span><br><span class="line">  ParameterHandler&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    <span class="comment">//参数注解解析</span></span><br><span class="line">    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(</span><br><span class="line">        p, parameterType, annotations, annotation);</span><br><span class="line">    <span class="keyword">if</span> (annotationAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"Multiple Retrofit annotations found, only one allowed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = annotationAction;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OKHttpCall"><a href="#OKHttpCall" class="headerlink" title="OKHttpCall"></a>OKHttpCall</h3><p>根据serviceMethod和请求参数，创建OkHttpCall对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;</span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="comment">// Either a RuntimeException, non-fatal Error, or IOException.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure;</span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serviceMethod和 args不做介绍了</p><ul><li>rawCall：OKHttp，真正发送网络请求</li><li>canceled：取消请求标志位</li><li>executed：是否执行标志位</li><li>creationFailure：异常标志位</li></ul><h3 id="adapt"><a href="#adapt" class="headerlink" title="adapt"></a>adapt</h3><p>根据ServiceMethod的中的callAdapter，来真正执行adapt方法<br>ServiceMethod的adapt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android 默认的返回 ExecutorCallAdapterFactory的Call<br>这里使用了静态代理delegate，加入一些额外的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory.ExecutorCallbackCall(ExecutorCallAdapterFactory.<span class="keyword">this</span>.callbackExecutor, call);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">   <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">   <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJavaCallAdapterFactory返回的是Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">  Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">      ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</span><br><span class="line">      : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line">  Observable&lt;?&gt; observable;</span><br><span class="line">  <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observable = responseObservable;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    observable = observable.subscribeOn(scheduler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> observable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面几步操作 <code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;)</code>，返回了一个 OKHttpCall 对象。</p><h2 id="发送网络请求-1"><a href="#发送网络请求-1" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>请求和 OKHttp 一样，分为同步请求和异步请求</p><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><p>execute 首先会调用ExecutorCallbackCall的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate代理实际是 OKHttpCall，最终会调用OKHttpCall的execute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  ......</span><br><span class="line">    call = rawCall;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">        throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">        creationFailure = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createRawCall"><a href="#createRawCall" class="headerlink" title="createRawCall"></a>createRawCall</h4><p>创建真正发送的请求Request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call = serviceMethod.toCall(args);</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用serviceMethod的 toCall 方法</span></span><br><span class="line">okhttp3.<span class="function">Call <span class="title">toCall</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//Request 的 builder 生成 Reuqest 对象</span></span><br><span class="line">  RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,</span><br><span class="line">      contentType, hasBody, isFormEncoded, isMultipart);</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line">  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line">  <span class="keyword">int</span> argumentCount = args != <span class="keyword">null</span> ? args.length : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (argumentCount != handlers.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument count ("</span> + argumentCount</span><br><span class="line">        + <span class="string">") doesn't match expected count ("</span> + handlers.length + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">    handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> callFactory.newCall(requestBuilder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parseResponse"><a href="#parseResponse" class="headerlink" title="parseResponse"></a>parseResponse</h4><p>调用OKHttp的execute发送网络请求，根据网络请求结果再进行结果解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line">  <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对响应码进行处理，再通过serviceMethod.toResponse选择数据转换器，对数据进行解析后，生成Response对象返回</p><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>异步请求的流程和同步请求一样，就是再回调处理会进行线程切换<br>ExecutorCallbackCall的enqueue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">  checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">  delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理执行加入了线程切换到逻辑，通过callbackExecutor切换到主线程<br>OKHttpCall的enqueue方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">  checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        throwIfFatal(t);</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">    callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">      Response&lt;T&gt; response;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">      callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用到RxJava，在上一节已经提到， adapt会进行适配，RxJava2CallAdapter的adapt方法中有对RxJava转换，具体逻辑实现这边先不展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">        ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</span><br><span class="line">        : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br></pre></td></tr></table></figure><h1 id="Retrofit中的HTTP实现"><a href="#Retrofit中的HTTP实现" class="headerlink" title="Retrofit中的HTTP实现"></a>Retrofit中的HTTP实现</h1><p>Retrofit真正请求网络，底层使用的是OKHttp，Refrofit主要负责网络请求接口的封装，看下源码中与HTTP相关的注解<br><img src="https://s2.ax1x.com/2019/08/17/munlOf.png" alt="Retrofit-HTTP"><br>这些注解都是在接口上的声明，主要是HTTP的请求方法和参数，具体可以参考<a href="/2019/07/12/Network-Http/#请求报文">Android网络编程-HTTP/HTTPS</a>，这里也不具体展开了</p><h1 id="设计模式应用"><a href="#设计模式应用" class="headerlink" title="设计模式应用"></a>设计模式应用</h1><p>我们再回顾下这张流程图:<br><img src="https://s2.ax1x.com/2019/08/17/muu48s.png" alt="retrofit-stay"></p><h2 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h2><p>这个模式运用的比较多，Retrofit的Builder，ServiceMethod的Builder等<br>设计模式可以参考<a href="http://c.biancheng.net/view/1354.html" target="_blank" rel="noopener">建造者模式（Bulider模式）详解</a></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在Retrofit 初始化，addCallAdapterFactory中的CallAdapter就是用工厂方法模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title">getParameterUpperBound</span><span class="params">(<span class="keyword">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Factory中抽象方法get，就会返回不同的 CallAdapter 对象<br>设计模式可以参考<a href="http://c.biancheng.net/view/1348.html" target="_blank" rel="noopener">工厂方法模式（详解版）</a></p><h2 id="外观模式-门面模式"><a href="#外观模式-门面模式" class="headerlink" title="外观模式(门面模式)"></a>外观模式(门面模式)</h2><p>Retrofit 就是一个典型的外观类，它屏蔽了所有的实现细节，提供给使用者方便的接口，统一调用创建接口实例和网络请求配置的方法<br>设计模式可以参考<a href="http://c.biancheng.net/view/1369.html" target="_blank" rel="noopener">外观模式（Facade模式）详解</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>主要应用CallAdapter类的adapt方法，在 Retrofit addCallAdapterFactory，对应 Factory 生成不同的CallAdapter，adapt就可以调用到不同实现<br>CallAdapter就是一个Strategy，Retrofit 对应上下文(Context)<br>设计模式可以参考<a href="http://c.biancheng.net/view/1378.html" target="_blank" rel="noopener">策略模式（策略设计模式）详解</a></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>还是在CallAdapter得到应用，Retrofit可以适配Android，Java8，RxJava,guava等平台， 不同平台有不同的特性，addCallAdapterFactory可以生成不同的平台的CallAdapter，把不同平台的特性，统一在一个接口中<br>设计模式可以参考<a href="http://c.biancheng.net/view/1361.html" target="_blank" rel="noopener">适配器模式（Adapter模式）详解</a></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>Retrofit实例的create方法，使用了动态代理模式，网络请求接口，都会调用到<code>Proxy.newProxyInstance</code>的 invoke 方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用动态代理，Retrofit 还使用了静态代理模式，ExecutorCallbackCall的delegate，在发送请求和接收响应的过程中，增加了一些额外逻辑 </p><pre><code class="java"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{  checkNotNull(callback, <span class="string">"callback == null"</span>);  delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() {    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>{      callbackExecutor.execute(<span class="keyword">new</span> Runnable() {        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{          <span class="keyword">if</span> (delegate.isCanceled()) {            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span>            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));          } <span class="keyword">else</span> {            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);          }        }      });    }    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>{      callbackExecutor.execute(<span class="keyword">new</span> Runnable() {        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{          callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);        }      });    }  });}</code></pre><p>设计模式可以参考<a href="http://c.biancheng.net/view/1359.html" target="_blank" rel="noopener">代理模式（代理设计模式）详解</a><br>Retrofit使用了大量的设计模式，上面只是在主流过程使用到的，其他设计模式的应用，大家可以继续深入源码去分析，总之，Refrofit框架是非常值得深入研究的框架</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit官网</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/73732115" target="_blank" rel="noopener">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></li><li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/index.html" target="_blank" rel="noopener">拆轮子系列：拆 Retrofit</a></li><li><a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></li><li><a href="https://segmentfault.com/a/1190000014823244" target="_blank" rel="noopener">Retrofit2 源码解析之动态代理</a></li><li><a href="https://www.jianshu.com/p/fb8d21978e38" target="_blank" rel="noopener">Retrofit分析-经典设计模式案例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。&lt;br&gt;Retofit是一个RESTful的HTTP网络请求框架，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于OKHttp&lt;/li&gt;
&lt;li&gt;通过注解配置网络请求参数&lt;/li&gt;
&lt;li&gt;支持同步、异步请求&lt;/li&gt;
&lt;li&gt;支持多种序列化、反序列化格式&lt;/li&gt;
&lt;li&gt;解耦彻底、模块高度封装，使用很多设计模式来实现
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
      <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
      <category term="Retrofit" scheme="http://yeungeek.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-OKHttp源码角度分析Http</title>
    <link href="http://yeungeek.github.io/2019/07/17/Network-OKHttp/"/>
    <id>http://yeungeek.github.io/2019/07/17/Network-OKHttp/</id>
    <published>2019-07-17T14:09:07.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了网络的基础知识，这篇主要从<code>OKHttp</code>源码角度来分析Http。<br><a href="https://github.com/square/okhttp/" target="_blank" rel="noopener">OKHttp</a>是一个优秀的网络请求框架，有以下特点：</p><ul><li>支持HTTP2/SPDY</li><li>Socket自动选择最好路线，并支持自动重连</li><li>拥有自动维护的Socket连接池，减少握手次数</li><li>拥有队列线程池，轻松写并发</li><li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）</li><li>实现基于Headers的缓存策略</li></ul><a id="more"></a><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步的Get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line"><span class="keyword">return</span> response.body().string();</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>异步的Get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                Log.e(<span class="string">"DEBUG"</span>, <span class="string">"##### onFailure: "</span>, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"DEBUG"</span>, <span class="string">"##### response: "</span> + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们从<code>OKHttp</code>的初始化开始分析。  </p><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>新建一个<code>OkHttpClient</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient();</span><br></pre></td></tr></table></figure><p>构造函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder模式构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">   protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">   connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">   eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">   proxySelector = ProxySelector.getDefault();</span><br><span class="line">   <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">      proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">   &#125;</span><br><span class="line">   cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">   socketFactory = SocketFactory.getDefault();</span><br><span class="line">   hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">   certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">   proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">   authenticator = Authenticator.NONE;</span><br><span class="line">   connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">   dns = Dns.SYSTEM;</span><br><span class="line">   followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">   followRedirects = <span class="keyword">true</span>;</span><br><span class="line">   retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">   callTimeout = <span class="number">0</span>;</span><br><span class="line">   connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">   readTimeout = <span class="number">10_000</span>;</span><br><span class="line">   writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">   pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了很多属性，具体含义，等后面用到在具体介绍。</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>请求流程可分为同步和异步，大体的请求流程如下图所示：<br><img src="https://s2.ax1x.com/2019/07/23/ekVFiV.png" alt="OKHttp流程"></p><h3 id="同步请求流程"><a href="#同步请求流程" class="headerlink" title="同步请求流程"></a>同步请求流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).execute();</span><br></pre></td></tr></table></figure><p>newCall返回的是<code>RealCall</code>，上面代码实际上执行的是<code>RealCall</code>的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>executed</code>判断Call对象是否已经执行，每个Call对象只能执行一次</p></li><li><p><code>client.dispatcher()</code>返回Dispatcher对象，任务核心调度类，是OKHttp中最重要类之一, executed方法把该线程添加到同步线程队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">  runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getResponseWithInterceptorChain()</code>获取HTTP请求结果，并会进行一系列拦截操作</p></li><li><p><code>client.dispatcher().finished(this)</code>执行完毕操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">   finished(runningSyncCalls, call);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>执行完毕后，会把线程从同步线程队列中移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异步方法中调用</span></span><br><span class="line">  <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步请求流程"><a href="#异步请求流程" class="headerlink" title="异步请求流程"></a>异步请求流程</h3><p><code>RealCall</code>的enqueue方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>executed</code>含义和同步请求一样，表示请求只能执行一次</li><li><code>client.dispatcher().enqueue(new AsyncCall(responseCallback));</code>，会生成一个<code>AsyncCall</code>对象，并把它加入到<code>readyAsyncCalls</code>线程队列中，等待执行</li></ul><p><code>AsyncCall</code>是<code>RealCall</code>的内部类，并且是<code>NamedRunnable</code>线程类，具体执行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = getResponseWithInterceptorChain();</span><br><span class="line">    signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">    responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getResponseWithInterceptorChain()</code>获取HTTP请求结果，并会进行一系列拦截操作</li><li><code>client.dispatcher().finished(this);</code>这个方法很重要，和同步方法中调用类似，但是异步的流程则完全不同</li></ul><p>finish方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  call.callsPerHost().decrementAndGet();</span><br><span class="line">  finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异步方法中调用</span></span><br><span class="line">  <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步流程中，<code>promoteAndExecute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会遍历异步等待线程队列，并对正在执行的异步线程队列进行最大请求size，以及每个host最大请求size进行检查。<br>把异步等待线程放到正在执行线程队列中，并在等待线程队列中删除该线程，这样就把等待线程变成正在执行线程。</p><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>任务调度核心类，这个类，其实在同步和异步请求流程中已经介绍过，其最重要功能是负责请求的分发。<br>Dispatcher在OKHttpClient的Builder中被初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"><span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"><span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>maxRequests：最大请求并发请求数64</li><li>maxRequestsPerHost：每个主机的最大请求数5</li><li>executorService：线程池</li><li>readyAsyncCalls：异步等待线程队列</li><li>runningAsyncCalls：正在运行的异步线程队列</li><li>runningSyncCalls：正在运行的同步线程队列</li></ul><p>线程池executorService的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数为0，表示线程在空闲时不会被保留，等待一段时间后停止</li><li>最大线程数Integer.MAX_VALUE，基本上就是可以创建线程无上限</li><li>keepAliveTime为60s，表示如果线程空闲时，最多只能存活60s</li></ul><p>综合上诉，在OKHttp中，设置了不设上限的线程，不保留最小线程，线程空闲时，最大存活时间为60s，保证I/O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。并通过<code>maxRequests</code>和<code>maxRequestsPerHost</code>来控制并发最大请求数。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在同步和异步请求中，具体的执行过程中都会调用到<code>getResponseWithInterceptorChain</code>方法，该方法添加了一系列的拦截器，它在OKHttp整理流程中处于非常重要的地位，<br><img src="https://s2.ax1x.com/2019/07/23/ekW4US.png" alt="流程"></p><p>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认添加的拦截器：</p><ul><li>RetryAndFollowUpInterceptor：负责失败重试以及重定向</li><li>BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li><li>CacheInterceptor：负责读取缓存直接返回、更新缓存</li><li>ConnectInterceptor：负责和服务器建立连接</li><li>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据</li></ul><p>这是典型的责任链模式，通过<code>Interceptor</code>，把Request转换为Response，每个<code>Interceptor</code>都有各自的责任和逻辑。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interceptors.addAll(client.interceptors());</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>开发者可以自己定义<code>Interceptor</code>，在最开始或者发送请求前，对Request和Response进行处理。</p><h2 id="HTTP实现"><a href="#HTTP实现" class="headerlink" title="HTTP实现"></a>HTTP实现</h2><p>OKHttp中实现HTTP主要是在<code>ConnectInterceptor</code>和<code>CallServerInterceptor</code>。   <code>ConnectInterceptor</code>建立服务器之间的连接，<code>CallServerInterceptor</code>发送请求和读取响应。<br>OKHttp请求一个URL的流程：</p><blockquote><ol><li>根据请求的URL，createAddress方法会创建一个Address，用于连接服务器</li><li>检查address和routes，是否可以从ConnectionPool获取一个连接</li><li>如果没有获取到连接，会进行下一个路由选择(<code>routeSelector</code>)，并且重新尝试从ConnectionPool获取一个连接。重试还是获取不到，就会重新创建一个连接(<code>RealConnection</code>)</li><li>获取连接后，它会与服务器建立一个直接的Socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接</li><li>发送HTTP请求，并获取响应</li></ol></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>在请求发送前的逻辑，都是<code>ConnectInterceptor</code>中实现，<code>ConnectInterceptor</code>的intercept，这个是3.14.2版本源码，和以前多版本稍微有些区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  Transmitter transmitter = realChain.transmitter();</span><br><span class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">  Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exchange</code>可以传输HTTP请求和响应，并管理连接和事件。<br>newExchange方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class="line"><span class="function">Exchange <span class="title">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot make a new request because the previous response "</span></span><br><span class="line">          + <span class="string">"is still open: please call response.close()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">  Exchange result = <span class="keyword">new</span> Exchange(<span class="keyword">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find方法会最终执行<code>ExchangeFinder</code>的<code>findConnection</code>方法，在发送HTTP请求之前的逻辑，都是这个方法中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class="line"><span class="comment"> * then the pool, finally building a new connection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">  RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">  Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">  RealConnection releasedConnection;</span><br><span class="line">  Socket toClose;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.根据 Address 从连接池获取连接</span></span><br><span class="line">      <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        selectedRoute = nextRouteToTry;</span><br><span class="line">        nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">        selectedRoute = transmitter.connection.route();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 3. 重新选择路由</span></span><br><span class="line">  <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">  <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">    newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">    routeSelection = routeSelector.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">      <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">      <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">      routes = routeSelection.getAll();</span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">          address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">      <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        selectedRoute = routeSelection.next();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 3. 重新选择路由，创建新的 `RealConnection`</span></span><br><span class="line">      <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">      <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">      result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">      connectingConnection = result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 4. 进行 Socket 连接</span></span><br><span class="line">  <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled, call, eventListener);</span><br><span class="line">  connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">  Socket socket = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span></span><br><span class="line">    <span class="comment">// concurrent connections to the same host.</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">      result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">      socket = result.socket();</span><br><span class="line">      result = transmitter.connection;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//把连接放入连接池中</span></span><br><span class="line">      connectionPool.put(result);</span><br><span class="line">      transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP 的连接主要是result.connect方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 循环中检查这个连接是否是隧道协议连接。<br><code>connectSocket</code>连接socket，<code>establishProtocol</code>根据HTTP协议版本进行连接处理。<br>重点分析下<code>connectSocket</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">   EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//连接 socket</span></span><br><span class="line">      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">      ConnectException ce = <span class="keyword">new</span> ConnectException(<span class="string">"Failed to connect to "</span> + route.socketAddress());</span><br><span class="line">      ce.initCause(e);</span><br><span class="line">      <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">      sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(npe);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Okio，封装了Socket的读写操作， 建立连接后，就可以发送请求和获取响应。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>CallServerInterceptor的intercept()方法里负责发送请求和获取响应。<br>具体操作都是通过Exchange来执行，Exchange通过各个功能模块再进行分发处理。<br>通过 Socket 发送 HTTP消息，会按照以下声明周期：</p><ul><li>writeRequestHeaders发送 request Headers</li><li>如果有 request body，就通过 Sink 发送request body，然后关闭 Sink</li><li>readResponseHeaders获取 response Headers</li><li>通过Source读取 response body，然后关闭 Source</li></ul><h4 id="writeRequestHeaders"><a href="#writeRequestHeaders" class="headerlink" title="writeRequestHeaders"></a>writeRequestHeaders</h4><p>Exchange 调用writeRequestHeaders方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call);</span><br><span class="line">      codec.writeRequestHeaders(request);</span><br><span class="line">      eventListener.requestHeadersEnd(call, request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e);</span><br><span class="line">      trackFailure(e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际执行的方法codec实现类<code>Http1ExchangeCodec</code>(前面根据HTTP协议版本选择)的writeRequest方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns bytes of a request header for sending on an HTTP transport. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(Headers headers, String requestLine)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state != STATE_IDLE) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"state: "</span> + state);</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(<span class="string">": "</span>)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">  state = STATE_OPEN_REQUEST_BODY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="readResponseHeaders"><a href="#readResponseHeaders" class="headerlink" title="readResponseHeaders"></a>readResponseHeaders</h4><p>读取响应头部，<code>Http1ExchangeCodec</code>的readResponseHeaders方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">(<span class="keyword">boolean</span> expectContinue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"state: "</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    StatusLine statusLine = StatusLine.parse(readHeaderLine());</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">new</span> Response.Builder()</span><br><span class="line">        .protocol(statusLine.protocol)</span><br><span class="line">        .code(statusLine.code)</span><br><span class="line">        .message(statusLine.message)</span><br><span class="line">        .headers(readHeaders());</span><br><span class="line">    <span class="keyword">if</span> (expectContinue &amp;&amp; statusLine.code == HTTP_CONTINUE) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusLine.code == HTTP_CONTINUE) &#123;</span><br><span class="line">      state = STATE_READ_RESPONSE_HEADERS;</span><br><span class="line">      <span class="keyword">return</span> responseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    state = STATE_OPEN_RESPONSE_BODY;</span><br><span class="line">    <span class="keyword">return</span> responseBuilder;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    <span class="comment">// Provide more context if the server ends the stream before sending a response.</span></span><br><span class="line">    String address = <span class="string">"unknown"</span>;</span><br><span class="line">    <span class="keyword">if</span> (realConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      address = realConnection.route().address().url().redact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected end of stream on "</span></span><br><span class="line">        + address, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatusLine解析HTTP版本信息，<code>readHeaders()</code>读取response header 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Reads headers or trailers. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Headers <span class="title">readHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Headers.Builder headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">  <span class="comment">// parse the result headers until the first blank line</span></span><br><span class="line">  <span class="keyword">for</span> (String line; (line = readHeaderLine()).length() != <span class="number">0</span>; ) &#123;</span><br><span class="line">    Internal.instance.addLenient(headers, line);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> headers.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="response-body"><a href="#response-body" class="headerlink" title="response body"></a>response body</h4><p>解析 response body 内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">  <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">  response = response.newBuilder()</span><br><span class="line">      .body(Util.EMPTY_RESPONSE)</span><br><span class="line">      .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response = response.newBuilder()</span><br><span class="line">      .body(exchange.openResponseBody(response))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是websocket，调用Exchange的openResponseBody方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseBody <span class="title">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    eventListener.responseBodyStart(call);</span><br><span class="line">    String contentType = response.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">    <span class="keyword">long</span> contentLength = codec.reportedContentLength(response);</span><br><span class="line">    Source rawSource = codec.openResponseBodySource(response);</span><br><span class="line">    ResponseBodySource source = <span class="keyword">new</span> ResponseBodySource(rawSource, contentLength);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(source));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e);</span><br><span class="line">    trackFailure(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取返回的 body，通过 Source 转换为需要的数据类型，ResponseBody提供的 string()，转换为 String 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">string</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (BufferedSource source = source()) &#123;</span><br><span class="line">    Charset charset = Util.bomAwareCharset(source, charset());</span><br><span class="line">    <span class="keyword">return</span> source.readString(charset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述的分析，OKHttp是通过Okio操作Socket实现了Http协议，凭借高效的性能，Android系统从4.4版本开始，HTTP的实现已经替换为OKHttp。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">OKHttp源码解析(一)–初阶</a></li><li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面介绍了网络的基础知识，这篇主要从&lt;code&gt;OKHttp&lt;/code&gt;源码角度来分析Http。&lt;br&gt;&lt;a href=&quot;https://github.com/square/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OKHttp&lt;/a&gt;是一个优秀的网络请求框架，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持HTTP2/SPDY&lt;/li&gt;
&lt;li&gt;Socket自动选择最好路线，并支持自动重连&lt;/li&gt;
&lt;li&gt;拥有自动维护的Socket连接池，减少握手次数&lt;/li&gt;
&lt;li&gt;拥有队列线程池，轻松写并发&lt;/li&gt;
&lt;li&gt;拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）&lt;/li&gt;
&lt;li&gt;实现基于Headers的缓存策略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
      <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
      <category term="OKHttp" scheme="http://yeungeek.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Cookie，Session，Token</title>
    <link href="http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/"/>
    <id>http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/</id>
    <published>2019-07-15T23:04:35.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。</p><a id="more"></a><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie机制是在客户端实现，采用客户端保持状态的方案。<br>Cookie由服务端生成，发送给客户端(Set-Cookie)，客户端请求的时候会带上这个Cookie。<br>请求流程：<br><img src="https://s2.ax1x.com/2019/07/16/ZH7XAf.png" alt="请求流程"><br>Cookie字段：名字、值、过期时间、路径和域。路径与域一起构成Cookie的作用范围。<br>通过Chrome的开发者工具中看到，在github.com上保存在客户端的Cookie信息。<br><img src="https://s2.ax1x.com/2019/07/17/ZqcVOS.png" alt="ZqcVOS.png"></p><ul><li>Name：名字</li><li>Value：值</li><li>Domain：域</li><li>Path：路径</li><li>Expaires/Max-Age：过期时间</li></ul><p>上图中<code>logged_in</code>和<code>user_session</code>两个Cookie值表示登录github.com后保存下来的登录状态和Session。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session是在服务端实现，当客户端请求服务端时，服务端会检查请求中是否包含Session标识(Session id)，</p><ul><li>如果没有,那么服务端就生成一个随机的Session以及和它匹配的Session id,并将Session id返回给客户端。</li><li>如果有,那么服务器就在存储中根据Session id 查找到对应的Session。</li></ul><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>Token也称作令牌，由uid+time+sign[+固定参数]组成:</p><ul><li>uid：用户唯一身份标识</li><li>time：当前时间的时间戳</li><li>sign：签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器</li></ul><p>以下几点特性会让你在程序中使用基于Token的身份验证：</p><ul><li>无状态、可扩展</li><li>支持移动设备</li><li>跨程序调用</li><li>安全</li></ul><p>Token是有客户端来保存，用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。而认证的具体流程如下：</p><blockquote><p>客户端使用用户名跟密码请求登录<br>服务端收到请求，去验证用户名与密码<br>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端<br>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据  </p></blockquote><h2 id="第三方授权登录"><a href="#第三方授权登录" class="headerlink" title="第三方授权登录"></a>第三方授权登录</h2><p>这是Token的一种应用场景，使用OAuth实现。<br>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。<br>我们看下github的授权流程：<br><img src="https://s2.ax1x.com/2019/07/17/Zq5gJg.png" alt="Zq5gJg.png"></p><blockquote><p>图片来源：<a href="https://juejin.im/post/5c7bd93751882545194f88cb" target="_blank" rel="noopener">github 授权登录教程与如何设计第三方授权登录的用户表</a></p></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><table><thead><tr><th align="left">维度</th><th align="left">Cookie</th><th align="left">Sesson</th></tr></thead><tbody><tr><td align="left">存放位置</td><td align="left">客户端</td><td align="left">服务端</td></tr><tr><td align="left">存取方式</td><td align="left">只能保管ASCII字符串</td><td align="left">任何类型的数据</td></tr><tr><td align="left">安全性</td><td align="left">对客户端是可见的，<br>客户端的一些程序可能会窥探、<br>复制以至修正Cookie中的内容</td><td align="left">对客户端是透明的，<br>不存在敏感信息泄露的风险</td></tr><tr><td align="left">有效期</td><td align="left">可以保持很长时间不过期</td><td align="left">依赖于JSESSIONID的Cookie，<br>默许过期时间为–1，<br>只需关闭了浏览器，该Session就会失效</td></tr><tr><td align="left">跨域支持</td><td align="left">支持跨域名访问</td><td align="left">仅在它所在的域名内有效</td></tr></tbody></table><h2 id="Token和Session"><a href="#Token和Session" class="headerlink" title="Token和Session"></a>Token和Session</h2><p>作为身份认证Token安全性比Session好。<br>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。<br>Token,如果指的是OAuth Token 或类似的机制的话，提供的是<code>认证</code>和<code>授权</code> ，认证是针对用户，授权是针对App。 </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">Cookie、Session、Token那点事儿</a></li><li><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li><li><a href="https://juejin.im/post/5b32f82a518825749e4a218b" target="_blank" rel="noopener">精读《图解HTTP》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Session" scheme="http://yeungeek.github.io/tags/Session/"/>
    
      <category term="Cookie" scheme="http://yeungeek.github.io/tags/Cookie/"/>
    
      <category term="Token" scheme="http://yeungeek.github.io/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-HTTP/HTTPS</title>
    <link href="http://yeungeek.github.io/2019/07/12/Network-Http/"/>
    <id>http://yeungeek.github.io/2019/07/12/Network-Http/</id>
    <published>2019-07-12T10:09:56.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP/IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。<a id="more"></a><br>这是最基本的HTTP工作原理，如图所示:<br><img src="https://s2.ax1x.com/2019/07/12/ZfgnTU.jpg" alt="C/S架构"></p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>HTTP属于应用层，应用层传输的数据单位是报文。<br>HTTP报文分为请求报文和响应报文。  </p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="https://s2.ax1x.com/2019/07/13/Zhv4AO.jpg" alt="请求报文"><br>HTTP请求报文由以下4个部分组成:</p><ul><li>请求行：请求类型,要访问的资源以及所使用的HTTP版本。</li><li>请求头部：服务器要使用的附加信息。</li><li>空行：请求头部后面的空行是必须的</li><li>请求包体：可以添加任意的其他数据</li></ul><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行组成：请求方法，请求URL，协议版本。</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><table><thead><tr><th align="left">方法</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td><td align="left">用来请求访问已被URI标识的</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体</td><td align="left">POST主要用来传输数据，而GET主要用来获取资源</td></tr><tr><td align="left">HEAD</td><td align="left">获取报文首部</td><td align="left">和GET方法类似，但是不返回报文实体主体部分</td></tr><tr><td align="left">PUT</td><td align="left">上传文件</td><td align="left">用来传输文件，由于自身不带验证机制，任何人都可以上传文件</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件</td><td align="left">与PUT功能相反，并且同样不带验证机制</td></tr><tr><td align="left">OPTIONS</td><td align="left">查询支持的方法</td><td align="left">用来查询针对请求URI请求的资源支持的方法</td></tr><tr><td align="left">TRACE</td><td align="left">追踪路径</td><td align="left">服务器会将通信路径返回给客户端</td></tr><tr><td align="left">CONNECT</td><td align="left">要求用隧道协议连接代理</td><td align="left">使用 SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</td></tr></tbody></table><h4 id="请求URL"><a href="#请求URL" class="headerlink" title="请求URL"></a>请求URL</h4><p>URL(Uniform Resource Locator)统一资源定位符，表示资源的地点(互联网上的地址)。<br>URI(Uniform Resource Identifier)统一资源标识符，用字符串标识某一互联网资源，URL是URI的子集。  </p><h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><ul><li>HTTP/1.0：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用</li><li>HTTP/1.1：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本</li><li>HTTP/2.0：HTTP 2.0是下一代HTTP协议，目前应用还非常少</li></ul><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。<br>有4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段，<a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%e5%9b%9b%e3%80%81http-%e9%a6%96%e9%83%a8" target="_blank" rel="noopener">所有完整首部</a><br>这里我们先了解下常用的请求首部。   </p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">用户代理可处理的媒体类型</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">优先的内容编码<br>Accept-Encoding: gzip, deflate, br</td></tr><tr><td align="left">Authorization</td><td align="left">Web 认证信息</td></tr><tr><td align="left">Cache-Control</td><td align="left">控制缓存的行为</td></tr><tr><td align="left">Connection</td><td align="left">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="left">Content-Encoding</td><td align="left">实体主体适用的编码方式</td></tr><tr><td align="left">Content-Type</td><td align="left">实体主体的媒体类型</td></tr><tr><td align="left">Content-Length</td><td align="left">实体主体的大小</td></tr><tr><td align="left">Host</td><td align="left">请求资源所在服务器</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">服务器上次返回的<code>Last-Modified</code>日期，如果在这个日期之后，<br>请求的资源都没有更新过，则返回304 Not Modified响应</td></tr><tr><td align="left">If-None-Match</td><td align="left">比较实体标记，值为上一次返回的ETag，<br>一般会和<code>If-Modified-Since</code>一起返回</td></tr><tr><td align="left">Referer</td><td align="left">对请求中URI的原始获取方</td></tr><tr><td align="left">User-Agent</td><td align="left">HTTP 客户端程序的信息</td></tr><tr><td align="left">Cookie</td><td align="left">保存状态信息</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">指定报文主体的传输编码方式</td></tr></tbody></table><h3 id="请求包体"><a href="#请求包体" class="headerlink" title="请求包体"></a>请求包体</h3><p>请求包体不在 GET 方法中使用，而是在POST 方法中使用。<br>HTTP请求的请求体有三种不同的形式：</p><ul><li>任意类型：服务器不会解析请求体，请求体的处理需要自己解析，比如JSON</li><li>键值对(application/x-www-form-urlencoded)：最常见的 POST 提交数据的方式，表单模式</li><li>文件分割：请求体被分成为多个部分，文件上传时会被使用</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用抓包工具或者Chrome来查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /getconfig HTTP/<span class="number">1.1</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Dalvik/<span class="number">2.1</span>.0 (Linux; U; Android <span class="number">9</span>; Redmi Note <span class="number">7</span> MIUI/V10.3.2.0.PFGCNXM)</span><br><span class="line">Host: data.mistat.xiaomi.com</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">205</span></span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">app_id=<span class="number">1000274</span>&amp;app_version=<span class="number">10.8</span>.3</span><br></pre></td></tr></table></figure><ul><li>请求行：显示Post请求，协议版本为HTTP/1.1</li><li>请求头部：<code>Content-Type</code>,<code>User-Agent</code>,<code>Host</code>,<code>Accept-Encoding</code>,<code>Content-Length</code>,<code>Connection</code></li><li>请求体：Content-Type声明为键值对</li></ul><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="https://s2.ax1x.com/2019/07/13/Zhv5ND.jpg" alt="响应报文"><br>HTTP 响应报文由状态行、响应头部、空行和响应包体4个部分组成。</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态行由HTTP协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;<br>协议版本和请求中的对应，状态码和描述会一一对应。</p><h4 id="状态码、描述"><a href="#状态码、描述" class="headerlink" title="状态码、描述"></a>状态码、描述</h4><p>状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类：</p><ul><li>1xx：Informational（信息性状态码），接收的请求正在处理;</li><li>2xx：Success（成功状态码），请求正常处理完毕;</li><li>3xx：Redirection（重定向状态码），需要进行附加操作以完成请求;</li><li>4xx：Client Error（客户端错误状态码），服务器无法处理请求;</li><li>5xx：Server Error（服务器错误状态码），服务器处理请求出错;</li></ul><p>常用的一些状态码和描述</p><h5 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</td></tr></tbody></table><h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">200 OK</td><td align="left">请求成功</td></tr><tr><td align="left">204 No Content</td><td align="left">请求已经成功处理，但是返回的响应报文不包含实体的主体部分</td></tr><tr><td align="left">206 Partial Content</td><td align="left">表示客户端进行了范围请求，<br>响应报文包含由Content-Range指定范围的实体内容</td></tr></tbody></table><h5 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">301 Moved Permanently</td><td align="left">永久性重定向</td></tr><tr><td align="left">302 Found</td><td align="left">临时性重定向</td></tr><tr><td align="left">304 Not Modified</td><td align="left">如果请求报文首部包含一些条件，If-Match，If-Range, <br>If-Modified-Since，If-None-Match，，If-Unmodified-Since。<br>如果不满足条件，则服务器会返回 304 状态码</td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">临时重定向，与 302 的含义类似，<br>但是307要求浏览器不会把重定向请求的POST方法改成GET方法</td></tr></tbody></table><h5 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">400 Bad Request</td><td align="left">请求报文中存在语法错误</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">请求需要验证用户</td></tr><tr><td align="left">403 Forbidden</td><td align="left">访问权限问题</td></tr><tr><td align="left">404 Not Found</td><td align="left"></td></tr></tbody></table><h5 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">500 Internal Server Error</td><td align="left">服务器正在执行请求时发生错误</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">服务器正在执行请求时发生错误</td></tr></tbody></table><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>和请求头部一样，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。<br>常用的请求首部  </p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Cache-Control</td><td align="left">控制缓存的行为</td></tr><tr><td align="left">Connection</td><td align="left">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">指定报文主体的传输编码方式</td></tr><tr><td align="left">Content-Encoding</td><td align="left">实体主体适用的编码方式</td></tr><tr><td align="left">Content-Type</td><td align="left">实体主体的媒体类型</td></tr><tr><td align="left">Content-Length</td><td align="left">实体主体的大小</td></tr><tr><td align="left">Expires</td><td align="left">实体主体过期的日期时间</td></tr><tr><td align="left">ETag</td><td align="left">资源的匹配信息，和<code>If-Nome-Match</code>对应</td></tr><tr><td align="left">Date</td><td align="left">服务端</td></tr><tr><td align="left">Location</td><td align="left">令客户端重定向至指定 URI</td></tr><tr><td align="left">Server</td><td align="left">HTTP 服务器的安装信息</td></tr><tr><td align="left">Last-Modified</td><td align="left">资源的最后修改日期时间</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置Cookie，客户端得到响应报文后把 Cookie 内容保存到浏览器中</td></tr></tbody></table><p>其他更详细的首部信息，可以参考<a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%e5%9b%9b%e3%80%81http-%e9%a6%96%e9%83%a8" target="_blank" rel="noopener">这里</a>   </p><h3 id="响应包体"><a href="#响应包体" class="headerlink" title="响应包体"></a>响应包体</h3><p>服务器返回给客户端的文本信息。<br>和请求包体的分类一样。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Sat, <span class="number">13</span> Jul <span class="number">2019</span> <span class="number">08</span>:<span class="number">40</span>:<span class="number">52</span> GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-<span class="number">8</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"errorCode"</span>:-<span class="number">2</span>,<span class="string">"reason"</span>:<span class="string">"no changing"</span>,<span class="string">"result"</span>:<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>响应行：返回响应码200 Ok，表示服务端返回数据成功</li><li>响应头部：Content-Type设置返回的类型为JSON格式</li><li>响应包体：返回具体JSON数据</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。<br>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）<br><img src="https://s2.ax1x.com/2019/07/13/Z42xPO.jpg" alt="HTTPS"></p><h2 id="与HTTP区别"><a href="#与HTTP区别" class="headerlink" title="与HTTP区别"></a>与HTTP区别</h2><table><thead><tr><th align="left">协议</th><th align="left">原理</th><th align="left">数据格式</th><th align="left">传输速度</th><th align="left">端口</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">应用层</td><td align="left">明文传输</td><td align="left">三次握手，传输三个包</td><td align="left">80</td></tr><tr><td align="left">HTTPS</td><td align="left">传输层</td><td align="left">SSL加密</td><td align="left">三次握手基础上增加ssl握手(9个包)，<br>传输12个包</td><td align="left">443</td></tr></tbody></table><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="HTTP框架"><a href="#HTTP框架" class="headerlink" title="HTTP框架"></a>HTTP框架</h1><h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a><a href="https://github.com/google/volley" target="_blank" rel="noopener">Volley</a></h2><p>Volley是Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持OKHttp。</p><h2 id="OKHttp"><a href="#OKHttp" class="headerlink" title="OKHttp"></a><a href="https://github.com/square/okhttp/" target="_blank" rel="noopener">OKHttp</a></h2><p>OKHttp是Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步。<br>已被谷歌加入到Android的源码中。</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a></h2><p>Retrofit是Square公司出品的默认基于OKHttp 封装的一套 RESTful 网络请求框架</p><p>后续文章会从OKHttp、Retrofit角度来分析Http。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP" target="_blank" rel="noopener">Http</a></li><li><a href="https://juejin.im/post/5c98306bf265da60ed6eedbc" target="_blank" rel="noopener">这是一份全面&amp; 详细 HTTP协议 学习攻略</a></li><li><a href="https://juejin.im/post/5b32f82a518825749e4a218b" target="_blank" rel="noopener">精读《图解HTTP》</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP/IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。&lt;br&gt;HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
      <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
      <category term="Https" scheme="http://yeungeek.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Socket</title>
    <link href="http://yeungeek.github.io/2019/06/26/Network-Socket/"/>
    <id>http://yeungeek.github.io/2019/06/26/Network-Socket/</id>
    <published>2019-06-26T20:18:07.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>Socket在Android网络编程中，有着非常重要的作用。</p><h1 id="Socket基本概念"><a href="#Socket基本概念" class="headerlink" title="Socket基本概念"></a>Socket基本概念</h1><p>即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。<br>从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><a id="more"></a><p>借用下网上结构图:<br><img src="https://s2.ax1x.com/2019/07/10/Z6bGHx.png" alt="Socket"><br>IP地址和端口号组成了Socket，都是成对出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;(IP地址<span class="number">1</span>:PORT端口号)，(IP地址<span class="number">2</span>:PORT端口号)&#125;</span><br></pre></td></tr></table></figure><p>单独的Socke是没用任何作用的,基于一定的协议（TCP或者UDP）下的Socket编程才能进行数据传输。</p><h1 id="Socket工作流程"><a href="#Socket工作流程" class="headerlink" title="Socket工作流程"></a>Socket工作流程</h1><p><img src="https://s2.ax1x.com/2019/07/11/ZR3W2n.jpg" alt="Socket工作流程"><br>服务端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。<br>客户端初始化一个socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务端的连接就建立了。<br>客户端发送数据请求，服务端接收请求并处理请求，然后把回应数据发给客户端，客户端读取数据，最后关闭数据，一次交互结束。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Socket使用类型有两种：</p><ul><li>基于TCP协议，流套接字，采用流的方式提供可靠的字节流服务</li><li>基于UDP协议，数据报套接字，采用数据报文提供数据打包发送的服务</li></ul><h1 id="基于TCP的Socket编程"><a href="#基于TCP的Socket编程" class="headerlink" title="基于TCP的Socket编程"></a>基于TCP的Socket编程</h1><h2 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br></pre></td></tr></table></figure><p>创建流套接字并将其连接到指定主机上的指定端口号。</p><ul><li><code>host</code>: 主机地址</li><li><code>port</code>: 端口号</li></ul><h4 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream"></a>getInputStream</h4><p>返回Socket的输入流，用户接受数据。</p><h4 id="getOutputStream"><a href="#getOutputStream" class="headerlink" title="getOutputStream"></a>getOutputStream</h4><p>返回Socket的输出流，用于发送数据。</p><h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>Socket的服务端实现</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>创建服务端Socket，绑定到指定端口。</p><ul><li><code>port</code>: 端口号</li></ul><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>监听并接受到此套接字的连接。该方法将阻塞，直到建立连接。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2. 监听</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">"server start listen"</span>);</span><br><span class="line">        <span class="comment">//3. 输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">        String content = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((content = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server receiver: "</span> + sb.toString());</span><br><span class="line"></span><br><span class="line">        socket.shutdownInput();</span><br><span class="line"></span><br><span class="line">        br.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的Socket服务端，接收到客户端的数据，就会关闭当前的连接。这个示例只是展示了一个完整的流程。<br>如果需要复杂的服务端实现，可以使用Netty、Mina或者其他Socket框架。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建客户端</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"your ip"</span>, <span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2. 输出流</span></span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line"><span class="comment">//3. 发送数据</span></span><br><span class="line">os.write(<span class="string">"Hello world"</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"send message"</span>);</span><br><span class="line">os.flush();</span><br><span class="line"></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>客户端就是连接后，发送了一份数据，就关闭连接了。<br>这样就实现了客户端和服务端的通信。</p><h1 id="基于UDP的Socket编程"><a href="#基于UDP的Socket编程" class="headerlink" title="基于UDP的Socket编程"></a>基于UDP的Socket编程</h1><h2 id="主要API-1"><a href="#主要API-1" class="headerlink" title="主要API"></a>主要API</h2><h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>用来包装接收和发送的数据。</p><ul><li>构造接收数据包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>用来接收长度为 length 的数据包。</p><ul><li>构造发送数据包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length,SocketAddress address)</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port)</span><br></pre></td></tr></table></figure><p>用来将长度为 length 的包发送到指定主机上的指定端口号。</p><h3 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h3><p>用来发送和接收数据报包的套接字。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数据报套接字并将其绑定到本地主机上的指定端口</span></span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据报套接字，将其绑定到指定的本地地址</span></span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port, InetAddress laddr)</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span></span></span><br></pre></td></tr></table></figure><p>DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号</p><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span></span></span><br></pre></td></tr></table></figure><p>当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// receive</span></span><br><span class="line">        <span class="comment">// 1.create</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="comment">// 2.create udp socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 3. receive start</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// 4. receive data</span></span><br><span class="line">        System.out.println(<span class="string">"sever: "</span> + <span class="keyword">new</span> String(buf, <span class="number">0</span>, buf.length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send</span></span><br><span class="line">        DatagramPacket p = <span class="keyword">new</span> DatagramPacket(buf, buf.length, </span><br><span class="line">                        packet.getAddress(), packet.getPort());</span><br><span class="line">        socket.send(p);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send</span></span><br><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"your ip"</span>);</span><br><span class="line"><span class="comment">//1.create packet</span></span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length, address, <span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2.create socket</span></span><br><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//3.send data</span></span><br><span class="line">socket.send(packet);</span><br><span class="line"><span class="comment">// receive</span></span><br><span class="line"><span class="comment">//1.create packet</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket receiverPacket = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line">socket.receive(receiverPacket);</span><br><span class="line">System.out.println(<span class="string">"client: "</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>客户端和服务端的实现，都比较简单。</p><p>关于Socket编程，就介绍好了，这篇只是开了头，最主要的还是得去项目中实践。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/089fb79e308b" target="_blank" rel="noopener">Android：这是一份很详细的Socket使用攻略</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html" target="_blank" rel="noopener">Scoket编程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Socket在Android网络编程中，有着非常重要的作用。&lt;/p&gt;
&lt;h1 id=&quot;Socket基本概念&quot;&gt;&lt;a href=&quot;#Socket基本概念&quot; class=&quot;headerlink&quot; title=&quot;Socket基本概念&quot;&gt;&lt;/a&gt;Socket基本概念&lt;/h1&gt;&lt;p&gt;即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。&lt;br&gt;从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。&lt;/p&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
      <category term="Socket" scheme="http://yeungeek.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-TCP/IP协议</title>
    <link href="http://yeungeek.github.io/2019/06/21/Network-TCP-IP/"/>
    <id>http://yeungeek.github.io/2019/06/21/Network-TCP-IP/</id>
    <published>2019-06-21T11:28:07.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2019/06/14/Network-Basic/">Android网络编程-计算机网络基础</a>一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。<br>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。<br>TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。<br>UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。</p><a id="more"></a><h1 id="数据报文"><a href="#数据报文" class="headerlink" title="数据报文"></a>数据报文</h1><p>在不同层传输的数据单位名称不同，在网络层传输的叫数据报，在传输层传输的叫报文段。</p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>IP数据报格式如下图:<br><a href="https://imgchr.com/i/ZkNR7d" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/24/ZkNR7d.jpg" alt="IP数据报"></a><br>各个字段的详细说明：</p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">版本</td><td align="left">4bit</td><td align="left">IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6</td></tr><tr><td align="left">首部长度</td><td align="left">4bit</td><td align="left">IP报头的长度，最大长度60字节(15*4)，<br>分为固定部分的长度(20字节)和可变部分的长度</td></tr><tr><td align="left">服务类型</td><td align="left">8bit</td><td align="left">Type Of Service</td></tr><tr><td align="left">总长度</td><td align="left">16bit</td><td align="left">IP报文的总长度。数据报的最大长度为 65535 字节</td></tr><tr><td align="left">标识</td><td align="left">16bit</td><td align="left">它是一个计数器，用来产生数据报的标识。<br>当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，<br>此标识表示同一个数据报的分片。</td></tr><tr><td align="left">标志</td><td align="left">3bit</td><td align="left">R、DF、MF三位，目前只有后两位有效。<br>DF位：为1表示不分片，为0表示分片。<br>MF：为1表示“更多的片”，为0表示这是最后一片。</td></tr><tr><td align="left">片偏移</td><td align="left">13bit</td><td align="left">本分片在原先数据报文中相对首位的偏移位。<br>片偏移以8个字节为偏移单位。</td></tr><tr><td align="left">生存时间</td><td align="left">8bit</td><td align="left">TTL (Time To Live)表示数据报在网络中的寿命，其单位为秒。<br>在目前的实际应用中，常以“跳”为单位。</td></tr><tr><td align="left">协议</td><td align="left">8bit</td><td align="left">指出IP报文携带的数据使用的哪种协议，<br>以便目的主机的IP层能知道要将数据报上交到哪个进程。<br>TCP的协议号为6，UDP的协议号为17。<br>ICMP的协议号为1，IGMP的协议号为2.</td></tr><tr><td align="left">首部校验和</td><td align="left">16bit</td><td align="left">计算IP头部的校验和，检查IP报头的完整性。</td></tr><tr><td align="left">源地址</td><td align="left">32bit</td><td align="left">标识IP数据报的源端设备。</td></tr><tr><td align="left">目的地址</td><td align="left">32bit</td><td align="left">标识IP数据报的目的地址。</td></tr><tr><td align="left">可选字段</td><td align="left">长度可变</td><td align="left">1～40 字节，用于增加IP数据报的控制功能。</td></tr><tr><td align="left">填充</td><td align="left"></td><td align="left">保证IP首部长度是4字节的整倍数</td></tr></tbody></table><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p><a href="https://imgchr.com/i/Zkc0N8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/24/Zkc0N8.md.png" alt="TCP报文"></a></p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">16bit</td><td align="left">数据发送方的端口号</td></tr><tr><td align="left">目的端口</td><td align="left">16bit</td><td align="left">数据接受方的端口号</td></tr><tr><td align="left">序号</td><td align="left">32bit</td><td align="left">本数据报文中的的第一个字节的序号<br>(在数据流中每个字节都对应一个序号)</td></tr><tr><td align="left">确认号</td><td align="left">32bit</td><td align="left">希望收到的下一个数据报文中的第一个字节的序号</td></tr><tr><td align="left">数据偏移</td><td align="left">4bit</td><td align="left">表示本报文数据段距离报文段有多远</td></tr><tr><td align="left">保留字段</td><td align="left">6bit</td><td align="left">保留为今后使用，但目前应置为0</td></tr><tr><td align="left">紧急比特URG</td><td align="left"></td><td align="left">当值为1时表示次报文段中有需要紧急处理</td></tr><tr><td align="left">确认比特ACK</td><td align="left"></td><td align="left">值为1时确认号有效，值为0时确认号无效</td></tr><tr><td align="left">复位比特RST</td><td align="left"></td><td align="left">值为1时表示TCP连接存在严重的错误，需要重新进行连接</td></tr><tr><td align="left">同步比特SYN</td><td align="left"></td><td align="left">值为1表示这是一个连接请求或连接接受报文</td></tr><tr><td align="left">终止比特FIN</td><td align="left"></td><td align="left">值为1表示要发送的数据报已经发送完毕，需要释放传送连接</td></tr><tr><td align="left">窗口</td><td align="left">16bit</td><td align="left">TCP连接的一端根据缓存空间的大小来确定自己接受窗口的大小<br>限制发送放的窗口上限</td></tr><tr><td align="left">检验和</td><td align="left">16bit</td><td align="left">用来检验首部和数据两部分的正确性</td></tr><tr><td align="left">紧急指针字段</td><td align="left">16bit</td><td align="left">紧急指针指出在本报文段中的紧急数据的最后一个字节的序号</td></tr><tr><td align="left">选项字段</td><td align="left">长度可变</td><td align="left">TCP 首部可以有多达40字节的可选信息，<br>用于把附加信息传递给终点，或用来对齐其它选项</td></tr></tbody></table><h2 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h2><p>相对于TCP报文，UDP报文简单了很多。<br><img src="https://s2.ax1x.com/2019/06/24/ZEKjVP.png" alt="UDP报文"></p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">16bit</td><td align="left">数据发送方的端口号</td></tr><tr><td align="left">目的端口</td><td align="left">16bit</td><td align="left">数据接受方的端口号</td></tr><tr><td align="left">包长度</td><td align="left">16bit</td><td align="left">UDP首部的长度和数据的长度之和。单位为字节</td></tr><tr><td align="left">校验和</td><td align="left">16bit</td><td align="left">用来检验首部和数据两部分的正确性</td></tr></tbody></table><h1 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h1><p>TCP用三次握手来创建连接，使用四次分手来释放连接。<br><a href="https://imgchr.com/i/ZEMwMd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/24/ZEMwMd.md.png" alt="三次握手"></a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小的信息。<br>握手过程：</p><blockquote><ol><li>第一次握手：建立连接，客户端先发送连接请求报文，将SYN设置为1，Sequence Number为x。客户端进入SYN+SEND状态，等待服务器确认。</li><li>第二次握手：服务器收到SYN报文。服务器收到客户端的SYN报文，需要对这个SYN报文进行确认，设置Acknowledgment Number为x+1(Sequence+1)；同时，自己还要送法SYN消息，将SYN位置为1，Sequence Number为y；服务器将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN+RECV状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK报文段。然后将Acknowlegment Number设为y+1,向服务器发送ACK报文段，这个报文段发送完毕后，客户端端服务器都进入ESTABLISHED状态，完成TCP三次握手。</li></ol></blockquote><p>完成了三次握手，客户端和服务器就可以开始传送数据了。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当客户端和服务端传输数据完毕后，需要断开TCP连接。TCP断开的过程，就是四次挥手。</p><blockquote><ol><li>第一次挥手：客户端(也可以是服务器)，设置Sequence Number和Acknowledgment Number，向服务器发送一个FIN报文段。此时客户端进入FIN_WAIT_1状态；这表示客户端没有数据发送给主机了。</li><li>第二次挥手：服务器收到客户端发来的FIN报文段，向客户端回一个ACK报文段，Acknowledgement Number为Sequence Number加1；客户端进入FIN_WAIT_2状态，服务器进入CLOSE_WAIT状态；服务器告诉客户端，我同意你的”关闭”请求。</li><li>第三次挥手：服务器向客户端发送FIN报文段，请求关闭连接，同时服务器进入LAST_ACK状态。</li><li>第四次挥手：客户端收到服务器发送的FIN报文段，向主机发送ACK报文段，然后客户端进入TIME_WAIT状态，服务器收到客户端的ACK报文段以后，就关闭连接，此时，客户端等待2MSL后一次没有到收到回复，则证明服务端已正常关闭，那好，客户端也可以关闭连接了。</li></ol></blockquote><h2 id="TCP三次握手的必要性"><a href="#TCP三次握手的必要性" class="headerlink" title="TCP三次握手的必要性"></a>TCP三次握手的必要性</h2><p>防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源。</p><h2 id="TCP四次挥手的必要性"><a href="#TCP四次挥手的必要性" class="headerlink" title="TCP四次挥手的必要性"></a>TCP四次挥手的必要性</h2><p>为了保证通信双方都能通知对方，需释放、断开连接。</p><h3 id="为什么客户端关闭连接前要等待2MSL时间"><a href="#为什么客户端关闭连接前要等待2MSL时间" class="headerlink" title="为什么客户端关闭连接前要等待2MSL时间"></a>为什么客户端关闭连接前要等待2MSL时间</h3><blockquote><p>MSL: 最大报文段生存时间</p></blockquote><p>四个报文发送完毕后，就可以直接进入CLOSE状态了，但是有可能网络是不可靠的，一切都可能发生，比如有可能最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。展开具体来讲：  </p><ul><li>为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接。</li><li>防止早已失效的连接请求报文，出现在本连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。</li></ul><h1 id="TCP、UDP比较"><a href="#TCP、UDP比较" class="headerlink" title="TCP、UDP比较"></a>TCP、UDP比较</h1><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">无连接</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">低效</td><td align="left">高效</td></tr><tr><td align="left">双工性</td><td align="left">全双工</td><td align="left">一对一，一对多，多对一，多对多<br>支持多播和广播</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口机制</td><td align="left"></td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始/拥塞避免<br>快重传/快恢复</td><td align="left"></td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场景</td><td align="left">效率要求相对低，准确要求相对高。<br>要求有连接的场景</td><td align="left">效率要求相对高，准确要求相对低</td></tr><tr><td align="left">应用</td><td align="left">SMTP，TELNET，HTTP，FTP</td><td align="left">DNS，RIP，NFS，SNMP，<br>IP电话，流媒体</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">计算机网络：这是一份全面 &amp; 详细 的TCP协议攻略</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/5987827.html" target="_blank" rel="noopener">《图解TCP/IP》读书笔记</a></li><li><a href="https://juejin.im/post/5a2614b8f265da432652af7d" target="_blank" rel="noopener">Android网络编程：基础理论汇总</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2019/06/14/Network-Basic/&quot;&gt;Android网络编程-计算机网络基础&lt;/a&gt;一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。&lt;br&gt;IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。&lt;br&gt;TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。&lt;br&gt;UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。&lt;/p&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="TCP" scheme="http://yeungeek.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://yeungeek.github.io/tags/UDP/"/>
    
      <category term="IP" scheme="http://yeungeek.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-计算机网络基础</title>
    <link href="http://yeungeek.github.io/2019/06/14/Network-Basic/"/>
    <id>http://yeungeek.github.io/2019/06/14/Network-Basic/</id>
    <published>2019-06-14T22:58:01.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>从本篇开始，真正进入我们的Android网络编程学习之旅。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。</p><a id="more"></a><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><blockquote><p>计算机网络体系结构可以定义为是网络协议的层次划分与各层协议的集合，同一层中的协议根据该层所要实现的功能来确定。各对等层之间的协议功能由相应的底层提供服务完成。<br>—— 百度百科</p></blockquote><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>对于复杂的计算机网络协议，结构分层很有必要。就像Android开发中，把应用分层各个模块。<br><img src="https://s2.ax1x.com/2019/06/19/VOlsPS.png" alt="VOlsPS.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li><code>各层之间相互独立。</code>某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间接口（即界面）所提供的服务</li><li><code>灵活性好。</code>当任何一层发送变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响</li><li><code>结构上可分割开。</code>各层都可以采用最合适的技术来实现</li><li><code>易于实现和维护。</code> 这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统</li><li><code>能促进标准化工作。</code>因为每一层的功能及其所提供的服务都已有了精确的说明</li></ul><p>缺点：<br>各层之间会有相同的功能出现，产生额外开销。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>目前有3种体系结构:</p><ul><li>OSI参考模型，概念清楚，理论也较完整，但它既复杂又不实用</li><li>TCP/IP体系结构，是一系列网络协议的总称，目前应用最广泛</li><li>五层体系结构，综合OSI和TCP/IP的优点,既简洁又能将概念阐述清楚</li></ul><p><a href="https://imgchr.com/i/VjDXwV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/20/VjDXwV.md.png" alt="体系结构"></a></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th align="center">分层</th><th align="left">功能</th><th align="left">数据单位</th><th align="left">协议栈</th></tr></thead><tbody><tr><td align="center">物理层</td><td align="left">屏蔽传输媒体和通信手段的差异</td><td align="left">比特(bit)</td><td align="left"></td></tr><tr><td align="center">数据链路层</td><td align="left">互连设备之间传送和识别数据帧</td><td align="left">帧(frame)</td><td align="left">点对点协议<br>以太网协议 <br>高级数据链路协议<br>帧中继</td></tr><tr><td align="center">网络层</td><td align="left">地址管理和路由选择</td><td align="left">数据报(datagram)</td><td align="left">IP协议<br>路由选择协议</td></tr><tr><td align="center">传输层</td><td align="left">管理两个节点之间的数据传输 <br> 负责可靠传输（确保数据被可靠地传送到目标地址）</td><td align="left">报文段(segment)</td><td align="left">TCP协议<br>UDP协议</td></tr><tr><td align="center">会话层</td><td align="left">通信管理。负责建立和断开通信连接（数据流动的逻辑通路）<br> 提供了数据交换定界和同步功能 <br>管理传输层一下的分层</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">表示层</td><td align="left">数据压缩、加密以及数据描述</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">应用层</td><td align="left">针对特定应用的协议</td><td align="left">报文(message)</td><td align="left">HTTP<br>DNS<br>FTP<br>SMTP<br>SSH</td></tr></tbody></table><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP的体系结构比较简单，只有四层。<br>它并不是遵循严格的 OSI 分层概念，应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。可以演化成如下图所示:<br><a href="https://imgchr.com/i/Vjvt4f" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/20/Vjvt4f.png" alt="tcp/ip"></a></p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><p>OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层的体系结构。在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><h2 id="五层协议中各层的主要功能"><a href="#五层协议中各层的主要功能" class="headerlink" title="五层协议中各层的主要功能"></a>五层协议中各层的主要功能</h2><p>五层协议中，没有表示层和会话层，这两层的功能留给开发者来处理。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><img src="https://s2.ax1x.com/2019/06/20/VxGwmF.png" alt="物理层"><br>在物理层，定义了以下内容：  </p><ul><li>接口特性<ul><li>机械特性：规定了接口的几何形状等</li><li>电器特性：规定了接口使用的电平大小等</li><li>功能特性：规定了接口引脚个数及各项功能等</li><li>规程特性：定义了接口在工作过程中遵循的相应过程。</li></ul></li><li>比特编码：用比特对信息按照一定规则进行编码，用于传输</li><li>数据率：即数据传输速率</li><li>比特同步：时钟同步</li><li>通讯方式:<ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>双工通信：双向同时传输</li></ul></li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><a href="https://imgchr.com/i/VxJzDO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/20/VxJzDO.png" alt="数据链路层"></a><br>功能：</p><ul><li>负责结点-结点数据传输</li><li>组桢：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</li><li>物理寻址：在桢头添加发送端或接收端的物理地址标识数据帧的发送端或接收端。</li><li>流量控制：匹配发送端与接收端的发送速度与接收速度，避免数据淹没接收端。</li><li>差错控制：检测并重传损坏或丢失帧，并避免重复帧。</li><li>访问（接入）控制：在任一给定时刻决定哪个设备拥有链路（物理介质）的控制使用权。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><a href="https://imgchr.com/i/VxYDR1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/21/VxYDR1.md.png" alt="网络层"></a><br>功能:</p><ul><li>负责源主机到目的主机数据分组（packet）的交付（可能穿越多个网络）。</li><li>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址（穿越多个网络时，链路层的物理寻址并不能用）。</li><li>路由：路由器（或网关）互连网络，并路由分组至最终目的主机，进行路径选择。</li><li>分组转发</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节。<br><a href="https://imgchr.com/i/VxYHL8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/21/VxYHL8.md.png" alt="传输层"></a><br>功能:</p><ul><li>负责源-目的（端-端）（进程间）完整报文传输</li><li>报文分段与重组</li><li>SAP寻址：确保将完整报文提交给正确进程，如端口号</li><li>连接控制：负责端-端的连接控制（建立连接、拆除连接），是一种逻辑连接</li><li>流量控制：控制端-端传输的速度</li><li>差错控制：差错检测与纠正</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><a href="https://imgchr.com/i/VznKBR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/21/VznKBR.png" alt="应用层"></a><br>应用层直接为用户的应用进程提供服务</p><h2 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。<br>IP的主要作用就是在复杂的网络环境中将数据包发给最终的目标地址。<br>相关技术：  </p><ul><li>DNS：域名系统，一种分布式的网络目录服务，主要用于域名与IP地址的要互转换。</li><li>ARP：ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。不过，ARP只适用于IPv4，不适用于IPv6。</li><li>ICMP：Internet控制报文协议，作用是报告一些网络传输过程中的错误与做一些同步工作。</li><li>DHCP：动态主机配置协议，实现自动设置IP地址、统一管理IP地址分配。</li><li>NAT：网络地址转换，作用是将IP数据报头中的IP地址转换为另一个IP地址。</li><li>IP隧道：是一种数据包封装技术，它是将原始IP包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的IP包）的数据净荷中进行传输。</li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>传输控制协议(Transmission Control Protocol)，面向连接的、可靠的流协议，提供可靠的通信传输。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>用户数据报协议(User Datagram Protocol)，面向无连接的，具有不可靠性的数据报协议。</p><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>Routing protocol，是一种指定数据包转送方式的网上协议。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议(Hyper Text Transfer Protocol)，用于从万维网服务器传输超文本到本地浏览器的传送协议。</p><p><a href="/2019/06/13/Network-Series/#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">系列文章目录</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">趣谈网络协议</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/5987827.html" target="_blank" rel="noopener">《图解TCP/IP》读书笔记</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">计算机网络</a></li><li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa" target="_blank" rel="noopener">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li><li><a href="https://www.cnblogs.com/hithongming/p/9315907.html" target="_blank" rel="noopener">计算机网络的体系结构</a></li><li><a href="https://blog.maplemark.cn/2019/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html" target="_blank" rel="noopener">计算机网络体系结构</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本篇开始，真正进入我们的Android网络编程学习之旅。&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-系列文章</title>
    <link href="http://yeungeek.github.io/2019/06/13/Network-Series/"/>
    <id>http://yeungeek.github.io/2019/06/13/Network-Series/</id>
    <published>2019-06-13T23:34:10.000Z</published>
    <updated>2020-01-17T03:44:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发过程中，网络编程是必不可少的。<br>大家接触的<code>Volley</code>,<code>Retrofit</code>,<code>OKHttp</code>等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。</p><a id="more"></a><p>本系列会介绍计算机网络的基础、TCP/UDP、Http协议、Socket等，并从源码角度分析<code>Retrofit</code>、<code>OKHttp</code>，它们是如何实现Http的。  </p><blockquote><p>千里之行，始于足下。不管何时，我相信，扎实的功底和过硬的技术，都会是你职业发展的助力器。<br>                                           —- 极客时间《趣谈网络协议》刘超</p></blockquote><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ul><li><a href="/2019/06/14/Network-Basic/">01.Android网络编程-计算机网络基础</a></li><li><a href="/2019/06/21/Network-TCP-IP/">02.Android网络编程-TCP/IP协议</a></li><li><a href="/2019/06/26/Network-Socket/">03.Android网络编程-Socket</a></li><li><a href="/2019/07/12/Network-Http/">04.Android网络编程-HTTP/HTTPS</a></li><li><a href="/2019/07/15/Network-Cookie-Session-Token/">05.Android网络编程-Cookie，Session，Token</a></li><li><a href="/2019/07/17/Network-OKHttp/">06.Android网络编程-OKHttp源码角度分析Http</a></li><li><a href="/2019/07/25/Network-Retrofit/">07.Android网络编程-Retrofit源码角度分析Http</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5a2614b8f265da432652af7d" target="_blank" rel="noopener">Android网络编程：基础理论汇总</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">计算机网络</a></li><li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa" target="_blank" rel="noopener">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li><li><a href="http://liuwangshu.cn/tags/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">Android网络编程系列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发过程中，网络编程是必不可少的。&lt;br&gt;大家接触的&lt;code&gt;Volley&lt;/code&gt;,&lt;code&gt;Retrofit&lt;/code&gt;,&lt;code&gt;OKHttp&lt;/code&gt;等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
      <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
      <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
      <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
      <category term="OKHttp" scheme="http://yeungeek.github.io/tags/OKHttp/"/>
    
      <category term="Retrofit" scheme="http://yeungeek.github.io/tags/Retrofit/"/>
    
  </entry>
  
</feed>
